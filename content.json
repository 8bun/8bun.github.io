{"pages":[{"title":"About","date":"2019-06-28T04:38:10.007Z","path":"about/index.html","text":""},{"title":"最近在读《牛奶可乐经济学》","date":"2019-05-02T12:15:29.000Z","path":"ReadBook/index.html","text":""},{"title":"Categories","date":"2019-06-28T04:38:10.037Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2019-06-28T04:38:10.053Z","path":"tags/index.html","text":""}],"posts":[{"title":"Go瀹炵幇BSo实现BS模式三层结构","date":"2019-10-05T12:41:27.000Z","path":"2019/10/05/Go瀹炵幇BSo实现BS模式三层结构/","text":"PHP语言编写，与数据库交互的登录注册小Example，体现B/S三层结构 代码细节请点击：","tags":[{"name":"B/S架构","slug":"B-S架构","permalink":"https://8bun.github.io/tags/B-S架构/"}],"categories":[{"name":"Go","slug":"Go","permalink":"https://8bun.github.io/categories/Go/"}]},{"title":"Java之设计模式","date":"2019-10-05T12:04:40.000Z","path":"2019/10/05/Java之设计模式/","text":"生成器模式用法：当要创建一个具有复杂功能的对象时，我们可以使用一个简单对象来创建。它从小而简单的对象逐步创建更大更复杂的对象。生成器模式是另一个创建模式。 举例：当创建一个窗口作为我们应用程序的主窗口时，我们需要创建一个菜单，一个工具栏，然后添加菜单和工具栏。对于我们要创建的每个窗口，我们需要创建一个空窗口，创建菜单，创建工具栏，将菜单和工具栏安装到窗口。我们可以使用构建器模式来隐藏如何创建窗口的实现。 代码举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//Pizza属性类class Pizza &#123; private String dough = \"\"; private String sauce = \"\"; private String topping = \"\"; public void setDough (String dough) &#123; this.dough = dough; &#125; public void setSauce (String sauce) &#123; this.sauce = sauce; &#125; public void setTopping (String topping) &#123; this.topping = topping; &#125;&#125;//pizza生成器抽象类，相当于Pizza制作标准abstract class PizzaBuilder &#123; protected Pizza pizza;//创建Pizza对象 public void createNewPizzaProduct() &#123; pizza = new Pizza(); &#125;//将制作Pizza的方法抽象出来 public abstract void buildDough(); public abstract void buildSauce(); public abstract void buildTopping();//返回此Pizza，关键用法 public Pizza getPizza() &#123; return pizza; &#125;&#125;//具体的pizza生成器类，相当于Pizza制作具体到具体厂家class HawaiianPizzaBuilder extends PizzaBuilder &#123; public void buildDough() &#123; pizza.setDough(\"cross\"); &#125; public void buildSauce() &#123; pizza.setSauce(\"mild\"); &#125; public void buildTopping() &#123; pizza.setTopping(\"ham+pineapple\"); &#125;&#125;class SpicyPizzaBuilder extends PizzaBuilder &#123; public void buildDough() &#123; pizza.setDough(\"pan baked\"); &#125; public void buildSauce() &#123; pizza.setSauce(\"hot\"); &#125; public void buildTopping() &#123; pizza.setTopping(\"pepperoni+salami\"); &#125;&#125;//创建pizza，万恶的指挥者，构造传入具体厂家对象，利用厂家对象制作Pizza，并将Pizza放回供后面测试调用class Waiter &#123; private PizzaBuilder pizzaBuilder;//这两步可以用构造函数传入PizzaBuilder对象代替 public void setPizzaBuilder (PizzaBuilder pb) &#123; pizzaBuilder = pb; &#125; public Pizza getPizza() &#123; return pizzaBuilder.getPizza(); &#125;//提供一个方法将厂家的Pizza制作方法集合起来 public void constructPizza() &#123; pizzaBuilder.createNewPizzaProduct(); pizzaBuilder.buildDough(); pizzaBuilder.buildSauce(); pizzaBuilder.buildTopping(); &#125;&#125;//创建实例，Testclass BuilderExample &#123; public static void main(String[] args) &#123; Waiter waiter = new Waiter(); //构建Pizza制作厂家 PizzaBuilder hawaiian_pizzabuilder = new HawaiianPizzaBuilder(); PizzaBuilder spicy_pizzabuilder = new SpicyPizzaBuilder(); waiter.setPizzaBuilder ( hawaiian_pizzabuilder ); waiter.constructPizza(); //指挥者让厂家制作Pizza //为了构建一个复杂的Pizza对象，我们只需要利用Waiter这个简单对象即可 Pizza pizza = waiter.getPizza(); &#125;&#125;","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://8bun.github.io/tags/设计模式/"}],"categories":[{"name":"Java","slug":"Java","permalink":"https://8bun.github.io/categories/Java/"}]},{"title":"SSM理解","date":"2019-09-07T12:18:51.000Z","path":"2019/09/07/SSM理解/","text":"Spring父容器与SpringMVC子容器是如何体现出父子关系的？所谓容器，就是上下文，在这同一个上下文里，大家可以共享一些东西。 在Spring应用启动时，会先读取web.xml文件，调用ContextLoaderListener创建Spring容器，也就是你说的父容器。 123&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; Listener创建完之后，开始创建Servlet： 1234&lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;/servlet&gt; 这时候这个DispatcherServlet开始试图创建SpringMVC的ApplicationContext，它先找刚才由上面那个ContextLoaderListener创建的Spring的ApplicationContext，找到后，把Spring的ApplicationContext作为参数传给DispatcherServlet的ApplicationContext的setParent方法，这样SpringMVC的容器就变成了Spring容器的儿子。 因为在SpringMVC这个子容器创建的时候指定了它的Spring父容器，所以儿子能找到父亲，所以SpringMVC这个子容器里的Bean可以调用父容器的服务，而父容器不知道有这个儿子的存在（一个不负责任的父亲），父容器里的Bean不能调用子容器里的服务。 Spring和SpringMVC配置文件为什么要分开扫描平时我们在项目中注入关系是这样的顺序：在Service中注入Dao（初始化自动注入，利用@Autowired），接着在Controller里注入Service（初始化自动注入，利用@Autowired） 使用分开扫描的方式，一是为了使得父容器内的对象都能互相通信，二是为了让与浏览器显示息息相关的jsp文件直接关联的Controller与其他分隔开来，体现SpringMVC的思想。【在Controller里注入（可访问到，也就是子容器访问父容器对象）Service】。 事务为什么加在service层而不加在dao层。 在数据库中,所谓事务是指一组逻辑操作单元即一组sql语句。 当这个单元中的一部分操作失败,整个事务回滚，只有全部正确才完成提交。 判断事务是否配置成功的关键点在于出现异常时事务是否会回滚。 给Service层配置事务，因为一个Service层方法操作可以关联到多个Dao的操作。在Service层执行这些Dao操作，多Dao操作有失败全部回滚，成功则全部提交。 事务也一般放在service层进行配置，其原因可见： 当然，事务的aop配置也一般放在applicationContext.xml进行配置，因为其涉及到 Mybatis整合Spring的思路Mybatis是使用SqlSessionFactory产生dao代理对象间接控制，然后使用代理对象调用其操作数据库的dao方法，这就是Mybatis的主要工作所在了。 而Mybatis涉及到dao层的代理对象，也涉及到与数据源有关的SqlSessionFactory 总的来说，整合的思路： 主要是获取sqlSession对象，通过MapperScannerConfigurer 自动装配SqlSessionFactory 或 SqlSessionTemplate，MapperFactoryBean 创建的代理类实现了 UserMapper 接口,并且注入到应用程序中 整合方式详解： IOC控制反转和依赖注入控制反转：我们不需要去new对象，只需要告诉Spring去把我们这个对象的控制权交给Spring 依赖注入：告诉Spring我要用哪个对象，这个对象之前是被Spring控制的。","tags":[{"name":"Spring","slug":"Spring","permalink":"https://8bun.github.io/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://8bun.github.io/tags/SpringMVC/"},{"name":"Mabatis","slug":"Mabatis","permalink":"https://8bun.github.io/tags/Mabatis/"}],"categories":[{"name":"SSM","slug":"SSM","permalink":"https://8bun.github.io/categories/SSM/"}]},{"title":"自定义Mybatis","date":"2019-07-29T11:02:35.000Z","path":"2019/07/29/自定义Mybatis/","text":"Java与数据库交互的基本步骤 加载驱动类(com.mysql.jdbc.Driver) 获取Connection对象(通过url、user、password) 获取PreparedStatement操作对象(通过Connection对象以及SQL语句) 执行 返回ResultSet并进行遍历，使用List集合添加每一行的对象 返回List集合","tags":[{"name":"自定义Mybatis框架","slug":"自定义Mybatis框架","permalink":"https://8bun.github.io/tags/自定义Mybatis框架/"}],"categories":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://8bun.github.io/categories/Mybatis/"}]},{"title":"XML之xmlns相关","date":"2019-07-13T13:45:28.000Z","path":"2019/07/13/XML之xmlns相关/","text":"对于很多xml文件的开头，通常都会有类似如下的： 123&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; 可以这样理解： 首先这个文件是一个xml文件，那么文件里面的所有内容都符合xml语法规范， 开头的&lt;project&gt;&lt;/project&gt;这最外层同样也是一个xml文件的标签，后面那一长串也就是所谓的属性，其中xmlns表示命名空间，xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; 这表示默认命名空间（如果你的xml标签没有带任何前缀，则默认认定标签来自默认命名空间），而下面xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 这个命名空间里面的元素或者属性就必须要以xsi:这种方式来写，比如schemaLocation就是他的一个属性，所以写成xsi:schemaLocation，而默认命名空间不带类似xsi这种，其实xml标签名称有个专业叫法叫做QName，而如果没有前面的xsi:这种一般叫做NCName。 你会发现， 这个 xmlns:xsi 在不同的 xml 文档中似乎都会出现。 这是因为， xsi 已经成为了一个业界默认的用于 XSD（XML Schema Definition) 文件的命名空间。 所以像mvn里面的&lt;dependency&gt;这种就是默认命名空间下面的元素，最后那一行就表示把定义这个命名空间的schema文件给引用进来，好让eclipse这类型工具能够解析和验证你的xml文件是否符合语法规范。 xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;上面这行的语法其实是， xsi:schemaLocation = &quot;键&quot; &quot;值&quot;。即 xsi 命名空间下 schemaLocation元素的值为一个由空格分开的键值对。等同于&lt;import namespace=&quot;xxx&quot; schemaLocation=&quot;xxx.xsd&quot;/&gt;。","tags":[{"name":"xmlns","slug":"xmlns","permalink":"https://8bun.github.io/tags/xmlns/"},{"name":"命名空间","slug":"命名空间","permalink":"https://8bun.github.io/tags/命名空间/"}],"categories":[{"name":"xml","slug":"xml","permalink":"https://8bun.github.io/categories/xml/"}]},{"title":"PHP学习笔记","date":"2019-07-08T08:09:44.000Z","path":"2019/07/08/PHP学习笔记/","text":"PHP表单PHP脚本可以通过_GET或_POST来获取相应表单的提交内容。 预定义的$_REQUEST变量包含了 $_GET、$_POST 和 $_COOKIE 的内容。 $_REQUEST 变量可用来收集通过 GET 和 POST方法发送的表单数据。 函数传入表单元素name可以获取该name表单元素所填的值，函数返回该值或数组。 如果对于表单中的selector多w个option，你可以选择将该selector的name定义为一个数组，如name=p[]，这样，返回的就是一个所有被选择的option 的 value构成的p数组，当然，前提是你给selector设置了multiple=&quot;multiple&quot;。 所以，对于单选按钮，返回的name设置为变量，多选返回的name设置为数组。 应用如果在客户端就对表单进行验证，则可以减少服务器的负担，而且浏览器速度更快。 如果用户输入需要插入数据库，应该考虑使用服务器验证。在服务器验证表单的一种好的方式是，可以把表单的数据传给当前页面（异步提交的方式更好），而不是跳转到不同的页面。这样用户就可以在同一张表单页面得到错误信息。用户也就更容易发现错误了。 几个$_SERVER数组的区别URL 地址如下： 1http://www.5idev.com/php/index.php/test/foo?username=hbolive $_SERVER[&#39;PHP_SELF&#39;] 得到：/php/index.php/test/foo，一般用来引用当前网页地址，并且它是系统自动生成的全局变量 $_SERVER[&#39;SCRIPT_NAME&#39;] 得到：/php/index.php $_SERVER[&#39;REQUEST_URI&#39;]得到：/php/index.php/test/foo?username=hbolive 从该例子可以看出: $_SERVER[&#39;PHP_SELF&#39;]则反映的是 PHP 程序本身； $_SERVER[&#39;SCRIPT_NAME&#39;]反映的是程序文件本身（这在页面需要指向自己时非常有用）； $_SERVER[&#39;REQUEST_URI&#39;]则反映了完整 URL 地址（不包括主机名）。 _SERVER[&#39;PHP_SELF&#39;]的避免使用安全漏洞如果你有一段代码像这样： 12&lt;form action=\"&lt;?php echo $_SERVER['PHP_SELF']; ?&gt;\"&gt; &lt;input type=\"submit\" name=\"submit\" value=\"submit\" /&gt;&lt;/form&gt; 运行之后，你可在地址后面输入任何东西，检查元素之后会发现action发生了变化，如果你加入了一段js代码，则后果 将会直接影响页面的效果。这些都容易被黑客利用来修改页面中一些重要参数、全局变量等。 所以，一般使用如下方式可以解决上述问题： htmlentities($_SERVER[&#39;PHP_SELF&#39;])来替代简单的$_SERVER[&#39;PHP_SELF&#39;]； 可以的条件下，使用 $_SERVER[&#39;SCRIPT_NAME&#39;] 或 $_SERVER[&#39;REQUEST_URI&#39;] 替代 $_SERVER[&#39;PHP_SELF&#39;] CookieCookie 是什么 Cookie 是浏览器访问服务器后，服务器传给浏览器的一段数据。 浏览器需要保存这段数据，不得轻易删除。 此后每次浏览器访问该服务器，都必须带上这段数据。 Cookie就是这么简单，这就是 Web 开发里 Cookie 的含义。 如何使用 CookieCookie 一般有两个作用。 第一个作用是识别用户身份。 比如用户 A 用浏览器访问了 http://a.com，那么 http://a.com 的服务器就会立刻给 A 返回一段数据「uid=1」（这就是 Cookie）。当 A再次访问 http://a.com 的其他页面时，就会附带上「uid=1」这段数据。 同理，用户 B 用浏览器访问 http://a.com 时，http://a.com 发现 B 没有附带 uid 数据，就给B 分配了一个新的 uid，为2，然后返回给 B 一段数据「uid=2」。B 之后访问 http://a.com 的时候，就会一直带上「uid=2」这段数据。 借此，http://a.com 的服务器就能区分 A 和 B 两个用户了。 第二个作用是记录历史。 假设 http://a.com 是一个购物网站，当 A 在上面将商品 A1 、A2 加入购物车时，Js、PHP都可以设置或改写 Cookie，改为「uid=1; cart=A1,A2」，表示购物车里有A1 和 A2 两样商品了。 这样一来，当用户关闭网页，过三天再打开网页的时候，依然可以看到 A1、A2躺在购物车里，因为浏览器并不会无缘无故地删除这个 Cookie。 借此，就达到里记录用户操作历史的目的了。（实际的网站使用 Cookie 时会更谨慎一些。） 在PHP中，当某个客户端向服务器第一次发起访问之后，服务器端运行的PHP文件中可以使用setCookie()函数生成Cookie，服务器把Cookie 发送到客户端并保存在客户端指定的路径下，你也可以设置保存的时间限制等。然后，在PHP中使用$_COOKIE[name]获取Cookie信息； Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。 Cookie注意事项 对于某些客户端是不支持或禁止Cookie的； 每个Cookie的内存限制为4KB左右； 只能有300个Cookie左右可以存储在客户端； 有些浏览器对Cookie“喜新厌旧”，尽管旧Cookie还未过期。 只要 Cookie 在设置的时候设置了只允许加密传输，Cookie 传递的时候就会只走加密的 HTTPS。 局限 cookie相对不是太安全，容易被盗用导致cookie欺骗 单个cookie的值最大只能存储4k，每次请求都要进行网络传输，占用带宽 用户信息既可以存储在sessioin中，也可以存储在cookie中，他们之间的差别在于session可以方便的存取多种数据类型，而cookie只支持字符串类型，同时对于一些安全性比较高的数据，cookie需要进行格式化与加密存储，而session存储在服务端则安全性较高。 Session由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识别具体的用户，这个机制就是session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。 cookie中就包含了一个叫PHPSESSID的会话ID唯一标识用户,这里用到了session。 简介 session是将用户的会话数据存储在服务端，没有大小限制 session 的工作机制是：为每个访客创建一个唯一的 id (UID)，并基于这个 UID 来存储变量。UID存储在 cookie 中，或者通过 URL进行传导。 通过一个session_id进行用户识别，PHP默认情况下session_id是通过cookie来保存的，因此从某种程度上来说，seesion依赖于cookie。 但这不是绝对的，session_id也可以通过参数来实现，只要能将session_id传递到服务端（如果用户浏览器不支持cookie或者关闭了它，session_id将会通过URL来传播，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。）进行识别的机制都可以使用session。 session信息存储在服务端，相对于存储在客户端的cookie更为安全，所以正常一般网站在用于“判断用户是否登录”时，确实是使用session，例如可以在session里存储如下一个数组。 12345//验证用户名和密码成功后$_SESSION['userinfo'] = [ 'uid' =&gt; 123, 'username' =&gt; 'testuser']; 而后在需要验证登录的地方加入类似如下判断 123if(empty($_SESSION['userinfo']) || empty($_SESSION['userinfo']['uid']))&#123; //未登录，引导登录&#125; 以上是使用session做用户登录的基本存储和验证逻辑，当然实际开发过程中会将这部分的代码封装。 注意点 在服务端保存session的方法很多，内存、数据库、文件都有。集群的时候也要考虑session的转移，在大型的网站，一般会有专门的session服务器集群，用来保存用户会话，这个时候 session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 session。 默认情况下，session是以文件形式存储在服务器上的，因此当一个页面开启了session之后，会独占这个session文件，这样会导致当前用户的其他并发访问无法执行而等待。可以采用缓存或者数据库的形式存储来解决这个问题。 默认情况下，session的超时时间（Timeout）是20分钟，即用户保持连续20分钟不访问网站，则session被收回。如果在这20分钟内用户又访问了一次页面，那么20分钟就重新计时了。 PHP编程在您把用户信息存储到PHP session中之前，首先必须启动会话。 使用session_start()启动会话，此时用户的会话被注册，然后使用$_SESSION数组存储session数据 您也可以通过调用 session_destroy()函数彻底销毁 session 。 PHP、MySQLPHP 5 及以上版本建议使用以下方式连接 MySQL : MySQLi extension (“i” 意为 improved) PDO (PHP Data Objects) 不同点MySQLi 和PDO 有它们自己的优势： PDO 应用在 12 种不同数据库中，MySQLi 只针对 MySQL 数据库。 所以，如果你的项目需要在多种数据库中切换，建议使用 PDO ，这样你只需要修改连接字符串和部分查询语句即可。 使用 MySQLi, 如果不同数据库，你需要重新编写所有代码，包括查询。 两者都是面向对象, 但 MySQLi 还提供了 API接口。 两者都支持预处理语句。 预处理语句可以防止 SQL注入，对于 web项目的安全性是非常重要的。 在使用之前需要先查看phpinfo()有没有mysqli和PDO的安装信息。 Ajaxajax的全称是AsynchronousJavascript+XML。异步传输+js+xml。所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果我们可以再来处理这个事。（当然，在其他语境下这个解释可能就不对了）这个很重要，如果不是这样的话，我们点完按钮，页面就会死在那里，其他的数据请求不会往下走了。这样比等待刷新似乎更加讨厌。（虽然提供异步通讯功能的组件默认情况下都是异步的，但它们也提供了同步选项，如果你好奇把那个选项改为false的话，你的页面就会死在那里）xml只是一种数据格式，在这件事里并不重要，我们在更新一行字的时候理论上说不需要这个格式，但如果我们更新很多内容，那么格式化的数据可以使我们有条理地去实现更新。 现在大部分人其实是用JSON这种格式来代替XML的，因为前者更加简洁，据说目前的解析速度也更快。多快好省，能省则省啊。 总结：只要是JS调用异步通讯组件并使用格式化的数据来更新web页面上的内容或操作过程，那么我们用的方法就可算是AJAX。","tags":[{"name":"PHP","slug":"PHP","permalink":"https://8bun.github.io/tags/PHP/"}],"categories":[{"name":"CS交互","slug":"CS交互","permalink":"https://8bun.github.io/categories/CS交互/"}]},{"title":"Git相关知识","date":"2019-07-05T05:43:44.000Z","path":"2019/07/05/Git相关知识/","text":"配置在为你的电脑安装完Git之后，因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。 注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 你可以在任何一个目录下进行git init操作，让Git系统来跟踪记录你的文件的修改情况。 工作区、暂存区以及版本库Git 工作区里面有一个隐藏目录.git，这个是Git 的版本库，一般作为隐藏目录存放，而不是工作区。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 如果你使用了git add &lt;file&gt;，操作正确之后则会将文件存储在stage暂存，然后使用git commit -m &quot;Info&quot;之后才会 提交添加到master分支上。commit面向多文件提交，add一般指向单文件；这时，你可以使用git status来查看版本库的状态。 其中HEAD指针指向当前版本 版本回退我们有时候要回退到之前文件的某个状态，可以使用git log来查看 从最近到最远的提交的日志，记录了你做了什么操作； 你也可以在后面加上--pretty=oneline让显示更加人性化。如 1234$ git log --pretty=oneline1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPLe475afc93c209a690c39c13a46716e8fa000c366 add distributedeaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file 你看到的一大串类似1094adb...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线： 在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 你可以使用git reset --hard HEAD^向前回退到上一版本。 你可以使用git reset HEAD &lt;file&gt;可以把暂存区的修改撤销掉（unstage），重新放回工作区。当我们用HEAD时，表示最新的版本。 你也可以使用git reflog来查看你的每一次命令，从而找到之前的commit id，向后回退到未来的哪个版本。 也可以使用git reset --hard 1094a回退到指定版本，版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。 管理修改注意，如果我们对某一文件进行：第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit 那么，第一次的修改被提交了，第二次的修改不会被提交，这是因为git commit只负责把暂存区的修改提交了； 当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有使用add放入暂存区 你可以使用git diff HEAD -- &lt;file&gt;来查看该文件的所有修改情况 你可以使用git checkout -- &lt;file&gt;来撤销你的修改。如果修改之前你已经将文件add到了暂存区，但还没commit，这时撤销修改后，就回到添加到暂存区后的状态，对实现这一操作目的的另一种做法是： 使用git reset HEAD &lt;file&gt;把暂存区的修改撤销掉（unstage），重新放回工作区。 注意：当我们用HEAD时，表示最新的版本。 如果修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态。 又到了小结时间。 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考上一节版本回退，不过前提是没有推送到远程库。 删除文件一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了：rm test.txt 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了。现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： 123$ git rm test.txtrm 'test.txt'$ git commit -m \"remove test.txt\" 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： 1$ git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 远程仓库找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。GitHub这个网站就是提供Git仓库托管服务的, 你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，需要配置SSH key的密钥对。 Git 服务器上存储的是公钥，你本地存储的是私钥，当你push本地代码库到远程代码库，服务器会要求你出示私钥，并且用你出示的私钥和它的公钥配对来完成认证。由于使用的是不对称加密，所以公钥可以公开，只要保管好私钥就可以。 关于密钥技术的相关知识，你可以访问：我的博客文章： 在Github上创建一个learngit仓库后，你可以根据GitHub的提示，在本地的learngit仓库下运行以下命令，你在本地关联的就是用户YourName的learngit远程库。 1$ git remote add origin git@github.com:Name/learngit.git 然后，可以使用 1$ git push -u origin master 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 从现在起，只要本地作了提交，就可以通过命令： 1$ git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！ SSH警告当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告： 123The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。 Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了： 1Warning: Permanently added &apos;github.com&apos; (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。 如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。 小结要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！ 要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。 Git支持https协议，也就是说你可以使用像https://github.com/michaelliao/gitskills.git这样的地址，但通过ssh支持的原生git协议速度最快。使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。 1git clone git@github.com:Name/learngit.git 实际上，Git支持多种协议，默认的git://使用ssh。 分支管理分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。 现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。 但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。 在Git里面，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。 Git 会使用 master 作为分支的默认名字。在若干次提交后，你其实已经有了一个指向最后一次提交对象的 master 分支，它在每次提交的时候都会自动向前移动。 那么，Git 是如何知道你当前在哪个分支上工作的呢？其实答案也很简单，它保存着一个名为 HEAD 的特别指针。 在 Git 中，它是一个指向你正在工作中的本地分支的指针（将 HEAD 想象为当前分支的别名。）。 运行git branch` 命令，仅仅是建立了一个新的分支，但不会自动切换到这个分支中去，所以在这个例子中，我们依然还在 master 分支里工作。 我们现在转换到新建的 testing分支： git checkout testing 然后HEAD就指向了testing分支： 提交文件后，现在 testing 分支往前移动了一格： 我们使用：git checkout master之后，HEAD 在一次 checkout 之后移动到了另一个分支，回到master分支上了： 下面与分支有关的常用命令： 查看分支：git branch 创建分支：git branch &lt;name&gt; 切换分支：git checkout &lt;name&gt; 创建+切换分支：git checkout -b &lt;name&gt; 合并某分支到当前分支：git merge &lt;name&gt; 删除分支：git branch -d &lt;name&gt; 如果在合并的分支中，有相同的文件但是拥有不一样的内容时，就会发生冲突，就必须首先解决冲突。解决冲突后，再提交，合并完成。 例如：我们在master和新创建的newbranch分支上，都分别修改了工作区的readme.txt，并都进行了add操作， 但是由于修改的内容不同，这时候，分支合并就会出现异常： 你可以使用git status或者cat readme.txt查看文件冲突：例如： 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，我们修改如下后保存： 1Creating a new branch is quick and simple. 再提交： 12$ git add readme.txt $ git commit -m \"conflict fixed\" 提交之后，分支延长， 现在，master分支和feature1分支变成了下图所示：（有同一向右的目的表示合并） 用带参数的git log --graph也可以看到分支的合并情况： 1234567891011121314$ git log --graph --pretty=oneline --abbrev-commit* cf810e4 (HEAD -&gt; master) conflict fixed|\\ | * 14096d0 (feature1) AND simple* | 5dc6824 &amp; simple|/ * b17d20e branch test* d46f35e (origin/master) remove test.txt* b84166e add test.txt* 519219b git tracks changes* e43a48b understand how stage works* 1094adb append GPL* e475afc add distributed* eaadf4e wrote a readme file 最后，删除feature1分支： 1$ git branch -d feature1 如果要丢弃一个没有被合并过的分支，可以通过git branch -D &lt;name&gt;强行删除。 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： 现在，如果你在当前状态下工作，但是其他地方需要紧急处理，你可以使用git stash来保存工作区的当前状态，此状态信息将会保存到栈中。你可以使用git stash list查看所有保存的状态。 你可以使用git stash apply恢复之前的状态，但恢复之后栈内的相应的状态信息记录不会被删除，你可以使用git stash drop来删除；你可以使用git stash pop来代替这恢复——删除的操作。 多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 本地分支往远程推送，需要同远程进行同步，需要注意本地分支： 因为master与远程master分支同步，所以需要时刻与远程同步； 开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； 你本人增加的用于修复bug的分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； 对于为新功能开发增加的新分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 要查看远程库的信息，可以使用git remote命令，或者使用git remote -v来查看更加详细的信息。 要从远程库中获取最新分支信息，并将该分支信息与本地分支信息进行合并，你可以使用 git pull ##远程主机（origin） #远程分支(next)#：#本地分支(master)# 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。 推送分支你可以使用git push origin &lt;branch-name&gt;将本地的branch-name分支向远程仓库推送，如果推送失败，则是因为远程分支比你的分支更新，需要解决冲突再推送。 接下来，当你的协作者再次从服务器上获取数据时，他们将得到一个新的远程分支 origin/&lt;branch-name&gt; 如果要把该远程分支的内容合并到当前分支，可以运行 git merge origin/&lt;branch-name&gt; 如果想在远程分支的基础上分化出一个新的分支来： git checkout -b &lt;local-branch&gt; origin/&lt;branch-name&gt; 这会切换到新建的 local-branch本地分支，这样你就可以在里面继续开发了。 建立关联并合并你可以使用以下命令建立本地当前的分支与远程分支的关联： 1$ git branch --set-upstream-to = origin/&lt;remote-branch&gt; &lt;local-branch&gt; 然后使用git pull将所有有关联的远程分支和本地分支进行合并。 如果git pull提示no tracking information，则说明本地分支和远程分支的关联没有创建 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin &lt;branch-name&gt;推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin &lt;branch-name&gt;推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 标签管理​ 标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 你可以按照简单易记的标签与复杂的commit id对应起来。 你可以使用类似的：git tag &lt;tag-name&gt; f52c633语句来为指定commit id附上标签。 如果你不加上上面f52c633参数，则默认为HEAD指向的commit id打标签。 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： 1$ git tag -a &lt;tag-name&gt; -m \"version 0.1 released\" 1094adb 使用git tag查看当前存在的所有标签； 使用git tag &lt;tag-name&gt;查看指定标签的详细信息； 如果要推送某个标签到远程，可以使用命令git push origin &lt;tag-name&gt;； 也可一次性推送全部尚未推送到远程的本地标签：$ git push origin --tags； 你也可以使用git tag -d &lt;tag-name&gt;来删除标签； 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除tag1： $ git tag -d tag1 然后，从远程删除。删除命令也是push，但是格式如下： $ git push origin :refs/tags/tag1 GitHub使用 在GitHub上，可以任意Fork开源仓库； 自己拥有Fork后的仓库的读写权限； 可以推送pull request给官方仓库来贡献代码。 使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况（原因你懂的）。 如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——码云（gitee.com）。 自定义Git让Git显示颜色，会让命令输出看起来更醒目： 1$ git config --global color.ui true 忽略特殊文件： 在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git 就会自动忽略这些文件。 有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了， 如果你确实想添加该文件，可以用-f强制添加到Git： git add -f &lt;file&gt; .gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理。 可以用git check-ignore命令检查忽略文件是否存在.gitignore文件中， git check-ignore -v &lt;file&gt; 更改命令别名你可以使用git config --global alias.&lt;another-name&gt; &lt;origin-name&gt;给origin-name命令起别名another-name 配置Git的时候，加上--global是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。 你可以在配置文件中查找别名： cat .git/config 当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中： 别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。 搭建Git服务器GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。 搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。 假设你已经有sudo权限的用户账号，下面，正式开始安装。 第一步，安装git： 1$ sudo apt-get install git 第二步，创建一个git用户，用来运行git服务： 1$ sudo adduser git 第三步，创建证书登录： 收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。 第四步，初始化Git仓库： 先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令： 1$ sudo git init --bare sample.git Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git： 1$ sudo chown -R git:git sample.git 第五步，禁用shell登录： 出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行： 1git:x:1001:1001:,,,:/home/git:/bin/bash 改为： 1git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。 第六步，克隆远程仓库： 现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行： 123$ git clone git@server:/srv/sample.gitCloning into &apos;sample&apos;...warning: You appear to have cloned an empty repository. 剩下的推送就简单了。 管理公钥如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。 这里我们不介绍怎么玩Gitosis了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。 管理权限有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。Gitolite就是这个工具。 这里我们也不介绍Gitolite了，不要把有限的生命浪费到权限斗争中。","tags":[{"name":"Git","slug":"Git","permalink":"https://8bun.github.io/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://8bun.github.io/tags/GitHub/"}],"categories":[{"name":"版本控制系统","slug":"版本控制系统","permalink":"https://8bun.github.io/categories/版本控制系统/"}]},{"title":"公钥、私钥和安全证书","date":"2019-07-03T14:59:43.000Z","path":"2019/07/03/公钥、私钥和安全证书/","text":"在学习 SSH 章节时，一定有不少人对公钥和私钥产生过不解。在搜索公钥跟私钥的理解时，发现了这篇有趣的图解小文章，与大家共享。 鲍勃有两把钥匙，一把是公钥，另一把是私钥。 鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。 苏珊要给鲍勃写一封保密的信。她写完后用鲍勃的公钥加密，就可以达到保密的效果。 鲍勃收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。 鲍勃给苏珊回信，决定采用”数字签名”。他写完后先用Hash函数，生成信件的摘要（digest）。 然后，鲍勃使用私钥，对这个摘要加密，生成”数字签名”（signature）。 鲍勃将这个签名，附在信件下面，一起发给苏珊。 苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。 苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。 复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，用自己的私钥做成”数字签名”，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。 后来，苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。 鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。 苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。 下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。 首先，客户端向服务器发出加密请求。 服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。 客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。 如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。 如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。 感谢转载：https://blog.csdn.net/gui951753/article/details/79252773","tags":[{"name":"公钥","slug":"公钥","permalink":"https://8bun.github.io/tags/公钥/"},{"name":"私钥","slug":"私钥","permalink":"https://8bun.github.io/tags/私钥/"},{"name":"安全证书","slug":"安全证书","permalink":"https://8bun.github.io/tags/安全证书/"}],"categories":[{"name":"密钥技术","slug":"密钥技术","permalink":"https://8bun.github.io/categories/密钥技术/"}]},{"title":"递归新理解","date":"2019-07-02T14:31:00.000Z","path":"2019/07/02/递归新理解/","text":"很简单的一个问题， 给定一个整数，要求对这个整数从大位数向小位数按顺序输出。 假定这个数是345，我们来分析一下下面这个程序： 123456789101112131415161718public class N &#123; //n=345，f(345)调用f(34)，f(34)调用f(3)，执行1 //回递，执行f(34)时的2语句 //执行f(345)时的2语句 void f(int n)&#123; if(n&lt;10) &#123; System.out.println(n); //1 &#125; else &#123; f(n/10); //345 System.out.println(n%10); //2 &#125; &#125; public static void main(String[] args) &#123; new N().f(345); &#125;&#125; 分析回递层之间的关系：f(3)执行完1语句后，递归向上返回到f(34)，而f(34)与f(3)的关系是: 123f(34) &#123; f(3), sout&lt;&lt;n%10；//所以输出了4；&#125; 同样地，对于f(345)，也有： 1234567891011f(345) &#123; f(34) , sout&lt;&lt;5 ; &#125; =&gt;&gt; f(345)&#123; &#123; f(3) , sout&lt;&lt;4 &#125; ,sout&lt;&lt;5 ; &#125; =&gt;&gt; f(345)&#123; sout&lt;&lt;3 , sout&lt;&lt;4, sout&lt;&lt;5 ; //所以结果是先输出3,再输出4，最后输出5 &#125;; 在做题的时候，你可以把这种递归调用的形式用自上而下的形式写出来，然后再分别找每一层与下面一层的关系，以及找到各层（每个被递归的函数）都做了什么。这样就对递归函数的执行有了更直观、深入的了解。 当然，了解递归的原理，还是要从内存的角度去理解的，这里只是记下分析递归的一个小的技巧。","tags":[{"name":"递归","slug":"递归","permalink":"https://8bun.github.io/tags/递归/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://8bun.github.io/categories/算法/"}]},{"title":"如何获取信息","date":"2019-07-01T05:03:19.000Z","path":"2019/07/01/如何获取信息/","text":"人是一台“电脑”假如将人比作一台电脑，需要输入信息，存储数据，运算思考，输出表达。而其中输入信息，作为第一步，也是非常重要的。那么作为一个成年人，应当怎么样去收集信息，才能够尽可能快，尽可能全面呢？ 从小到大，其实从来没有人教过我们如何收集信息，而这看起来好像是一个无意识的过程。不就是刷刷微博、看看新闻、读读书、看看文章嘛，大家都会嘛。然而，这种无意识，往往不是最有效的方式，甚至会让你觉得非常苦恼。 我一直在思考这个问题，如何搭建自己的信息收集渠道？因为过去收集信息，没有一个完整的体系，都是无头的苍蝇，乱撞。在浏览信息的时候，还容易因为一些别的话题将注意力分散开，像猴子掰玉米一样，大量的时间花在不断地分心上面，真正关心的信息却没有找到。 结构化思维方法首先，在找到答案前，先让我们确立一些原则。作为一个成年人，应当具备结构化的思维，这个是我的一个指导原则之一。其实我们遇到的大多数问题，是因为没有结构化思维工具，所以才会不知如何下手，不知道怎么收集信息，不知道怎么思考，不知道怎么做决定，等等。这些问题，统统都是因为没有一个稳定的思维结构，注定会导致过程的混乱和随意，最终得不到一个满意的答案。 结构化思维方法具有很多优势，它将问题拆分成更多维度，之前想到的是一个个零散的点，而结构化思维，让你从一个面、一个体、或者更高维度的视角去分析问题。这种多维度，让你看到事物的很多面，对事情有更加清晰的认识，将会帮助你解决手头的问题。 这个纷繁复杂的世界，就是由很多很多类的事物组成，而每一样事物，都有其规律可循，通过多个维度的观察、总结，那么你就更能掌握了这个规律，从而使得做起事情很轻松。 信息收集的方法论信息收集也一样，有它特有的方法论，总结了这种方法论，可以为绝大多数人、绝大多数场景使用。 信息结构模型信息包含了几种类型： 结构化的核心知识 零散的知识点 即时信息 我们的信息组成应当是一个同心圆，核心是一些最重要的结构化知识，这些知识需要艰苦地学习才能获得，成为我们思考和行动的最主要依据。比如从小接受的科学教育，让我们理解这个世界是由粒子组成，再比如，你的工作技能，需要辛苦习得，而且每天都在应用，这是我们每个人吃饭的家伙。 我们的信息结构不断完善的过程，就是新知识不断加入，融汇贯通到已有的结构里面，成为你信息结构的一部分。这个过程也是你的信息圈不断扩大的过程，它看起来就像是下面这样。 信息的重要性及时间分配根据二八法则，核心知识在我们的信息里面，是最重要的百分之八十，它们起的作用最大，而剩下的零散知识点和即时信息，则没有那么重要了。零散知识点可以作为我们扩展信息广度的方法，快速了解一些未掌握的信息。而即时信息，比如新闻、微博等，大多时候作为我们的一个社交谈资，作为一个普通人，你谈不谈论世界杯，也并不会对你生活有什么很大的影响。 重要的信息，需要我们花时间花精力去掌握，一门课程、一本书籍、一种技能，都需要扎扎实实地花时间去搭建整个结构。比如练吉他，首先需要知道一些简单的乐理，然后学会和弦、看谱，然后勤奋练习，最终才有可能弹奏出一首曲子来；而即时消息，则可以用一些碎片时间来刷，上班路上，刷一刷微信公众号和朋友圈，看看有啥新鲜事在发生。 所以时间分配上是：80%时间放在核心知识，剩余20%放在零散知识点和即时信息。 搭建你的信息渠道每个人都有自己常用的信息渠道，常见的有几种： 书籍 网络信息 社交圈 举个例子：小郑，是区块链工程师，他本科通过计算机科学专业的学习，掌握了编程的技能，他通过阅读技术书籍来学习新的技术，提高自己的水平，有时候他也逛逛知名博客以及开发者社区，了解一些技术动向。此外，他每天通过Reddit或者微博，看到一些新鲜事，他通过数字货币交流群里获得一些币圈消息，也会看朋友圈里面，大家发了什么新动态。 那么怎么设计自己的信息获取渠道呢？推荐的方法如下： 通过书籍、论文等来获得结构化的核心知识，比如一门学科、一种技术 通过杂志、网络的Wiki来辅助自己丰富要搭建的新知识结构，并且不断内化提升认知 通过朋友、社交网络来获取一手的新闻，但是前提是要加以甄别，做一个批判性信息收集者 时间上： 挤出大块的时间来啃结构化的核心知识（比如上学、上班期间，周末的一大块时间，集中精力攻克） 抽出一小块时间，浏览零散的信息（如微信公众号、社区文章、杂志等，也可以收藏以后再看，或者通过语音听取知识付费的文章） 利用碎片时间，瞥一下最新的快讯、新闻、消息推送（如ReadHub.me，消息来了看一眼，有个基本的判断就得了，不重要的略过，重要的要进入下一步） 行动上： 知道什么信息从什么地方获取，节省你的精力和时间（比如，你想知道怎么开发Android App，你有一个朋友就是做这个的，问问他就是了） 更加靠近准确信息的源头，有助于提升信息即时性和有效性 提高敏感度和执行力，核心知识上做好准备，得到最新消息后立即行动 最重要的还是我们自己无论收集的信息多么准确，多么及时，圈子多么大，最重要的还是我们自己，对关键信息是否敏感，对于信息的提取和利用是否有效。 如果对关键信息不敏感，那么也还是抓不住机会，比如，很早就知道比特币的人，可能通过朋友之口或者某个文章得知，但最终知道了就知道了，并没有深挖，也没有进一步行动，最终大腿拍烂，而有的人，抓住了一个信息，深挖下去，获得了回报。 对信息的提取和利用，如果获得了信息，首先要评判信息的真伪可靠性，做一些基本的调查和过滤，才能为你所用，而不能听风就是雨，这样你将会成为信息的奴隶，而不是信息的主人。 那么我们就要有意地锻炼自己的信息敏感度和提取信息、利用信息的能力，得到最新的消息，要试着想想这个消息蕴含着什么隐藏信息，是否代表着什么趋势和潮流，值不值得深挖下去。如果值得，那么深挖下去就好了，最终将信息为你所用。 最后信息，总是无处不在的，在于你用发现的眼光去看待它，并且找到一种合适的方法， 沉淀下来，最终成为你的一部分。 感谢转载：https://bibodeng.com/","tags":[{"name":"信息","slug":"信息","permalink":"https://8bun.github.io/tags/信息/"}],"categories":[{"name":"知识","slug":"知识","permalink":"https://8bun.github.io/categories/知识/"}]},{"title":"我对记忆的总结","date":"2019-06-29T11:23:57.000Z","path":"2019/06/29/我对记忆的总结/","text":"重复记忆的时间不要超过2天； 不加思考的盲目记笔记是低效率的记忆方式； “烂笔头”实现的“好记性”前提是思考和理解。 记忆也有试炼法记忆，此法适合于纠错（如常识性错误、意识性错误以及容易忽略的地方）; 人的状态和记忆效果有很大的关系，适当调整和休息（洗脸、洗澡等）有利于更高效的记忆。 实践是巩固记忆的重要途径，实践的方法的本质是”重复“，比如，对于重复记忆难以记住的内容，需要采用另外一种辅助记忆的形式去记忆，比如记忆科目三的路线，你可以看完视频后自己在纸上描绘路线以及一些注意点，然后再比对，你对知识错漏点就有了更加清晰的认识了；如果对于自己难以总结的内容，就可以采取询问的方式帮助自己记忆和总结，询问的帮助提高记忆的效率有时比你自己思考来的更高，比如记住某个高铁站的结构，当然最后还要加以自己的思考。实践证明，重复所能巩固这段记忆的效果比自己去摸索来得更好，是一种牺牲时间成本换取高效率的方式。","tags":[{"name":"记忆","slug":"记忆","permalink":"https://8bun.github.io/tags/记忆/"}],"categories":[{"name":"规律","slug":"规律","permalink":"https://8bun.github.io/categories/规律/"}]},{"title":"XDebug断点调试的工作原理","date":"2019-06-29T08:07:32.000Z","path":"2019/06/29/XDebug断点调试的工作原理/","text":"对于PHP开发，初来咋到，开发环境的搭建和理解感觉是最操逼的一件事了。不像JAVA，打开一个Eclipse就可以开搞，Php的Debug都要几个插件来配合工作。这些都是死的，好说。 对于Xdebug , 我的总结是： Xdebug的工作原理可以总结为下面几个步骤， 1）IDE（比如PhpStorm，下文所述的客户端）中已经集成了一个遵循BGDp的Xdebug插件。当要debug的时候，点击一些IDE的某个按钮，启动这个插件。该插件会启动一个9000的端口监听远程服务器发过来的debug信息。 2）浏览器向Httpd（Apache）服务器发送一个带有XDEBUG_SESSION_START参数的请求，Httpd收到这个请求之后交给后端的PHP进行处理（下面就忽略Httpd，直接把Php叫做Server）。 3）Php看到这个请求是带了XDEBUG_SESSION_START 参数，就告诉Xdebug，“嘿，我要debug喔，你准备一下”。这时，Xdebug这时会向来源ip客户端的9000端口（即客户端，也即是IDE）发送一个debug请求，然后客户端的9000端口响应这个请求，那么debug就开始了。 4）Php知道Xdebug已经准备好了，那么就开始开始一行一行的执行代码，但是每执行一行都会让Xdebug过滤一下。 5）Xdebug开始过滤代码，Xdebug在过滤每一行代码的时候，都会暂停代码的执行，然后向客户端的9000端口发送该行代码的执行情况，等待客户端的决策（是一句代码还是下一个断点待）。 6）相应，客户端（IDE）收到Xdebug发送过来的执行情况，就可以把这些信息展示给开发者看了，包括一些变量的值等。同时向Xdebug发送下一步应该什么。","tags":[{"name":"XDebug","slug":"XDebug","permalink":"https://8bun.github.io/tags/XDebug/"}],"categories":[{"name":"调试","slug":"调试","permalink":"https://8bun.github.io/categories/调试/"}]},{"title":"Vue之组件传值","date":"2019-05-13T10:57:55.000Z","path":"2019/05/13/Vue之组件传值/","text":"在学习前端框架Vue时，遇到了组件之间的传值问题，索性take a note。 组件父子组件父子关系即是组件 A 在它的模板中使用了组件 B，那么组件 A 就是父组件，组件 B 就是子组件。 我们可以这样理解：Vue实例就是一个父组件，而我们定义的组件（包括全局组件、私有组件）就都是子组件。 12345678910111213// 注册一个子组件Vue.component('child', &#123; data: function()&#123; return &#123; text: '我是father的子组件！' &#125; &#125;, template: '&lt;span&gt;&#123;&#123; text &#125;&#125;&lt;/span&gt;'&#125;)// 注册一个父组件Vue.component('father', &#123; template: '&lt;div&gt;&lt;child&gt;&lt;/child&gt;&lt;/div&gt;' //在模板中使用了child组件&#125;) 直接使用father组件的时候： 123&lt;div id=&quot;app&quot;&gt; &lt;father&gt;&lt;/father&gt;&lt;/div&gt; 页面中就会渲染出 ：我是father的子组件！ father 组件在模板中使用了 child 组件，所以它就是父组件，child 组件被使用，所以 child 组件就是子组件。 兄弟组件两个组件互不引用，则为兄弟组件。 123456Vue.component(&apos;brother1&apos;, &#123; template: &apos;&lt;div&gt;我是大哥&lt;/div&gt;&apos;&#125;)Vue.component(&apos;brother2&apos;, &#123; template: &apos;&lt;div&gt;我是小弟&lt;/div&gt;&apos;&#125;) 使用组件的时候： 1234&lt;div id=&quot;app&quot;&gt; &lt;brother1&gt;&lt;/brother1&gt; &lt;brother2&gt;&lt;/brother2&gt;&lt;/div&gt; 页面中就会渲染出 ： 我是大哥 我是小弟 Prop子组件想要使用父组件的数据，我们需要通过子组件的 props 选项来获得父组件传过来的数据。以下我使用在 .vue 文件中的格式来写例子。 在父组件 father.vue 中引用子组件 child.vue，把 name 的值传给 child 组件。 12345678910// child.vue&lt;template&gt; &lt;span&gt;Hello &#123;&#123;message&#125;&#125;&lt;/span&gt;&lt;/template&gt;&lt;script&gt; export default &#123; // 在 props 中声明获取父组件的数据通过 message 传过来，message为值的标签 props: [&apos;message&apos;] &#125;&lt;/script&gt; 1234567891011121314151617181920//father.vue&lt;template&gt; &lt;div class=&quot;app&quot;&gt; // message 定义在子组件的 props 中，message为值的标签，name为值的key &lt;child :message=&quot;name&quot;&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import child from &apos;./child.vue&apos;; export default &#123; components: &#123; child &#125;, data() &#123; return &#123; name: &apos;World&apos; &#125; &#125; &#125;&lt;/script&gt; 页面会渲染出Hello World 举例2： 在父组件传值的子组件内部定义prop数组，将父组件内部的data内部要传的数据的名称作为子组件引用值的属性的值， 如，有子组件component1，父组件div，在父组件内部引用子组件，子组件使用父组件的值， 要传父组件data中的msg：’父组件中的数据’，在子组件使用父组件的值时，如下使用v-bind定义属性名parent-msg作为使用值的标签（你也可以设置为:parentMsg）所以，在目的地子组件内部定义prop属性，值设置为parentMsg（驼峰式命名的 prop 需要转换为相对应的短横线隔开式 is-show）。然后:parentMsg的值，为msg（要传父组件data中的值的keyName） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"vue2.5.16.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 第三步：父组件在引用子组件的时候， 通过 属性绑定（v-bind:）的形式, --&gt; &lt;!--把需要传递给子组件的数据，以属性绑定的形式，传递到子组件内部，供子组件使用 --&gt; &lt;component1 v-bind:parent-msg=\"msg\"&gt;&lt;/component1&gt; &lt;/div&gt; &lt;!-- 定义子组件的模板 --&gt; &lt;template id=\"myTemplate\"&gt; &lt;!-- 第二步：在子组件的模板中，使用props中的属性 --&gt; &lt;h2 @click=\"change\"&gt;我是子组件。我想使用父组件中的数据parentMsg： &#123;&#123; parentMsg &#125;&#125;&lt;/h2&gt; &lt;/template&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', //在外面定义了id为app的组件作为父组件 data: &#123; msg: '父组件中的数据' &#125;, methods: &#123;&#125;, //自定义组件 components: &#123; // 自定义组件作为子组件时默认无法访问到父组件中的 data 中的数据 和 methods 中的方法 component1: &#123; //将组件的名称定义为 component1 template: '#myTemplate', //在外面定义了id为myTemplate的template data() &#123; // 注意： 自定义组件中的 data 数据，并不是通过 父组件传递过来的，而是组件自身私有的，比如： 子组件通过 Ajax ，请求回来的数据，都可以放到 data 身上； // data 上的数据，都是可读可写的 return &#123; title: '自定义组件私有的数据 title', content: '自定义组件私有的数据 content' &#125; &#125;, // 注意： 组件中的 所有 props 中的数据，都是通过 父组件 传递给子组件的 // props 中的数据，都是只读的，无法重新赋值 props: ['parentMsg'], // 第一步：把父组件传递过来的 parentMsg 属性，先在 props 数组中，定义一下，这样，才能使用这个数据 directives: &#123;&#125;, filters: &#123;&#125;, components: &#123;&#125;, methods: &#123; change() &#123; // 下面这行会报错，因为子组件不要直接修改父组件中的data数据 // this.parentMsg = '被修改了' &#125; &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 子组件中，data中的数据和props中的数据的区别： 子组件中的 data 数据，并不是通过 父组件传递过来的，而是子组件自身私有的，比如： 子组件通过 Ajax ，请求回来的数据，都可以放到 data 身上。props 中的数据，都是通过 父组件 传递给子组件的。 data中的数据是可读可写的；props中的属性只是可读的，无法重新赋值，重新赋值会报错（也就是说，子组件不要直接去修改父组件中的数据）。 父组件将方法传递给子组件 父组件通过事件绑定机制，将父组件的方法传递给子组件 代码举例： 下面例子，我们来演示 当点击子组件的按钮时，拿到父组件传递过来的 方法，并调用这个方法 我们在子组件的method中定义了一个函数来实现调用父组件的show函数，通过调用$emit函数，在子组件地方使用了@关键字来表示要调用父组件的事件属性parent-show，然后将函数名作为值，此时，对于$emit函数，我们使用事件属性名parent-show作为参数传入。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"vue2.5.16.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 父组件向子组件 传递 方法，是通过 事件绑定机制； v-on。当我们自定义了 一个 事件属性 parent-show（这 个地方不能用驼峰命名）之后，--&gt; &lt;!-- 那么，子组件就能够，通过 emit 来调用 传递进去的 这个 方法了 --&gt; &lt;!-- 【第一步】。意思是说，show是父组件的方法名，parent-show是自定义的事件属性，稍后要在子组件中用 到 --&gt; &lt;component1 @parent-show='show'&gt;&lt;/component1&gt; &lt;/div&gt; &lt;!-- 定义子组件的模板 --&gt; &lt;template id=\"myTemplate\"&gt; &lt;!-- 【第二步】按照正常的写法来：点击按钮，调用子组件的方法 --&gt; &lt;div @click=\"childClick\"&gt;我是子组件，点击调用父组件的方法&lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; //父组件的data &#125;, methods: &#123; show: function () &#123; // 定义父组件的show方法 console.log('父组件提供的方法'); &#125; &#125;, components: &#123; component1: &#123; //将子组件的名称定义为 component1 template: '#myTemplate', data() &#123; // 子组件的data return &#123; // content: '子组件私有的数据 content' &#125; &#125;, props: [''], directives: &#123;&#125;, filters: &#123;&#125;, components: &#123;&#125;, methods: &#123; childClick() &#123; // emit 英文原意： 是触发，调用、发射。意思是，触发父组件的方法 // 【第三步】 在子组件的方法中，通过 emit 触发父组件的方法 this.$emit('parent-show'); &#125; &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果：（点击子组件，触发了父组件的方法） 在这个过程中，我们对父组件传递的show的参数做一点点修改增加了两个参数，并实现将两个参数的值打印出来。 所以，在调用$emit函数的时候，就必须多传入两个参数。这样，我们实现了在子组件内部将数据作为参数传入到父组件。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"vue2.5.16.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;component1 @parent-show='show'&gt;&lt;/component1&gt; &lt;/div&gt; &lt;!-- 定义子组件的模板 --&gt; &lt;template id=\"myTemplate\"&gt; &lt;h2 @click=\"childClick\"&gt;我是子组件，点击调用父组件的方法&lt;/h2&gt; &lt;/template&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; //父组件的data // msg: '父组件中的数据' &#125;, methods: &#123; // 定义父组件的方法 show: function (arg1, arg2) &#123; //【第二步】父组件里放两个参数，这个两个参数就代表着子组件中的`child 123`、`child 789` console.log('父组件提供的方法'); console.log('打印子组件传递过来的参数。参数一：' + arg1 + '，参数二：'+ arg2); &#125; &#125;, components: &#123; component1: &#123; //将子组件的名称定义为 component1 template: '#myTemplate', data() &#123; // 子组件的data return &#123; // content: '子组件私有的数据 content' &#125; &#125;, props: [''], directives: &#123;&#125;, filters: &#123;&#125;, components: &#123;&#125;, methods: &#123; childClick() &#123; // 子组件如果要给父组件传递参数，在触发 emit 的时候，通过参数的形式带出去就可以了 // 【第一步】在子组件里，我们带两个参数出去，传给父组件 this.$emit('parent-show', 'child 123', 'child 789'); &#125; &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 我们还可以将子组件中的data数据传递给父组件，存放到父组件的data中， 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"vue2.5.16.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;component1 @parent-show='show'&gt;&lt;/component1&gt; &lt;/div&gt; &lt;!-- 定义子组件的模板 --&gt; &lt;template id=\"myTemplate\"&gt; &lt;h2 @click=\"childClick\"&gt;我是子组件，点击调用父组件的方法&lt;/h2&gt; &lt;/template&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; //父组件的data parentData: null &#125;, methods: &#123; // 定义父组件的方法 show: function (arg) &#123; //【第二步】父组件里放参数，这个参数就代表着子组件中的 child.data console.log('父组件提供的方法'); this.parentData = arg; //将参数arg传递给父组件的data，也就达到了目的：子组件传递数据，赋值给父组件 console.log('打印父组件的数据（这是子组件传过来的）：'+ JSON.stringify(this.parentData)); &#125; &#125;, components: &#123; component1: &#123; //将子组件的名称定义为 component1 template: '#myTemplate', data() &#123; // 子组件的data return &#123; childData: &#123; //定义自组件的数据 name: 'smyhvae', age: 26 &#125; &#125; &#125;, props: [''], directives: &#123;&#125;, filters: &#123;&#125;, components: &#123;&#125;, methods: &#123; childClick() &#123; // 子组件如果要给父组件传递参数，在触发 emit 的时候，通过参数的形式带出去就可以了 // 【第一步】在子组件里，通过传参的形式，把子组件的data，传给父组件 this.$emit('parent-show', this.childData); &#125; &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在Vue中，通过 ref 属性获取DOM元素我们当然可以使用JS原生的做法（document.getElementById）或者 jQuery 来获取DOM，但是这种做法却在无形中操作了DOM，在Vue框架中并不推荐这种做法。 我们可以通过ref属性获取DOM元素。 ref的英文单词是reference，表示引用。我们平时可以经常看到控制台会报错referenceError的错误，就和引用类型的数据有关。 在Vue中，通过 ref 属性获取DOM元素的步骤： （1）第一步：在标签中给 DOM 元素设置 ref 属性。 1&lt;h3 id=\"myH3\" ref=\"myTitle\"&gt; 今天天气太好了&lt;/h3&gt; （2）第二步：通过 this.this.$refs.xxx 获取 DOM 元素 1console.log(this.$refs.myTitle.innerText) 举例如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"vue2.5.16.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 第一步：在标签中给 DOM 元素设置 ref 属性 --&gt; &lt;h3 id=\"myH3\" ref=\"myTitle\"&gt; 今天天气太好了&lt;/h3&gt; &lt;input type=\"button\" value=\"按钮元素\" @click=\"getElement\" ref=\"myBtn\"&gt; &lt;/div&gt; &lt;script&gt; var login = &#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;', data() &#123; return &#123; msg: 'son msg' &#125; &#125;, methods: &#123; show() &#123; console.log('调用了子组件的方法') &#125; &#125; &#125; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getElement() &#123; // 原生js获取DOM元素 // console.log(document.getElementById('myTitle').innerText) // 第二步：通过 this.this.$refs.xxx 获取 DOM 元素 console.log(this.$refs.myTitle.innerText) &#125; &#125;, components: &#123; login &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行上方代码，然后我们在控制台输入vm，就可以看到： 使用 ref 属性获取整个子组件根据上面的例子，我们可以得出规律：只要ref属性加在了DOM元素身上，我们就可以获取这个DOM元素。 那我们可以通过ref属性获取整个Vue子组件吗？当然可以。这样做的意义是：**在父组件中通过ref属性拿到了子组件之后，就可以进一步拿到子组件中的data和method。 举例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"vue2.5.16.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"点击按钮\" @click=\"getElement\"&gt; &lt;login-component ref=\"loginTemplate\"&gt;&lt;/login-component&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getElement() &#123; //在父组件中，通过ref获取整个子组件，进而获取子组件的data console.log(this.$refs.loginTemplate.myData) //在父组件中，通过ref获取整个子组件，进而获取子组件的method this.$refs.loginTemplate.showMethod() &#125; &#125;, components: &#123; 'login-component': &#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;', data() &#123; return &#123; myData: '子组件的data' &#125; &#125;, methods: &#123; showMethod() &#123; console.log('调用子组件的method') &#125; &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 运行代码，点击按钮后，效果如下： 我们直接在控制台输入vm，可以看到：","tags":[{"name":"组件传值","slug":"组件传值","permalink":"https://8bun.github.io/tags/组件传值/"}],"categories":[{"name":"Vue","slug":"Vue","permalink":"https://8bun.github.io/categories/Vue/"}]},{"title":"网络之集线器、交换机和路由器异同之处","date":"2019-05-10T11:43:50.000Z","path":"2019/05/10/网络之集线器、交换机和路由器异同之处/","text":"我们知道，网络上数据包的传输需要经过集线器、交换机、路由器等设备，它们之间的紧密合作将各方各地的信息相互联系起来，起到了十分重要的作用。 信号从网卡流出进入网线的过程如下： 网卡中的PHY(物理层装置，以前低速方式中则称为介质连接单元，即MAU)模块将包转换为电信号之后，信号通过RJ-45接口进入双绞线。【以太网信号的本质是正负变化的电压，使用双绞线可以抵消螺旋产生噪声电流，抑制噪声】 然后，信号达到了集线器，这个过程中信号会因各种因素而衰减。 集线器将信号发给所有连接的线路，集线器的接口有一个为MDI/MDI-X切换开关，MDI（媒体相关接口）是对RJ-45接口和信号收发模块进行直连连线，而MDI-X则是交叉连线。由于集线器的接口一般为MDI-X模式，要将两台集线器相连时，就需要将其中一台改成MDI模式。如果集线器上没有MDI切换开关，而且所有的接口又都是MDI-X时，可以用交叉网线连接两台集线器。所谓交叉连线，就是讲发送和接收信号线反过来接的网线。 也就是说，网卡和集线器直接可以相连，网卡间也可以互连。 然后，信号到达集线器的PHY(MAU)模块之后，会进入中继电路。中继电路的基本功能是将信号进行广播到集线器的所有端口上，连接在端口上的计算机接收到这条广播信息时，会对信息进行检查，如果发现该信息是发给自己的，则接收，否则不予理睬。 不过，在将计算机直接连接在集线器上之前，是通过交换机来进行包的转发的，然后抵达集线器。 交换机也具有多个端口，每个端口都有独立的PHY(MAU)、MAC（不具有MAC地址）和内存，一般都是通过一个控制芯片来同时控制多个端口。 交换机内部具有对转发的包进行缓存的缓冲区以及记录转发包的接收方MAC地址以及对应的端口、控制信息等的MAC地址表，端口和MAC地址是一一对应的（设备连接在交换机端口上）。MAC地址表是具有定时清除的功能。交换机的构造决定了其具有全双工的功能，可同时进行接收和发送。 网络包到达集线器的广播和交换机的转发之后，就到达了路由器了。 路由器是基于IP进行设计的，路由器内部也具有路由表，其记录的信息项为目标IP地址、子网掩码、网关、接口、跃点数等，通过进行查表判断转发目标。路由器的各个端口模块各不相同，其中包含ADSL、FTTH、通信线路、无线局域网、以太网端口等。经过哪个端口的工作过程是取决于端口对应的通信技术。如果数据包过大，则可能进行分片操作。接收包进来之后，模块会在路由表中查询包应该转发的端口。通过查询到表中IP对应的网关，如果网关为空，则IP头部中接收方IP地址就是下一个转发目标；否则，网关地址则为下一个转发目标。路由器也会根据ARP进行查询IP对应下一个转发目标的MAC地址，即转发给下一个对应的路由器。 此外，在内网和互联网进行相连的过程中，路由器还可被人为地加入设计成进行地址的转换的设备群，一个公有地址可分配给多个私有内网地址（：端口号）。另外，根据一些设定的规则，路由器还可设定为包的过滤（相当于防火墙）。","tags":[{"name":"集线器","slug":"集线器","permalink":"https://8bun.github.io/tags/集线器/"},{"name":"交换机","slug":"交换机","permalink":"https://8bun.github.io/tags/交换机/"},{"name":"路由器","slug":"路由器","permalink":"https://8bun.github.io/tags/路由器/"}],"categories":[{"name":"网络","slug":"网络","permalink":"https://8bun.github.io/categories/网络/"}]},{"title":"Vue之事件修饰符","date":"2019-05-07T14:17:40.000Z","path":"2019/05/07/Vue之事件修饰符/","text":"这些时间自学 Vue 框架，遇到了其事件修饰，感觉挺有意思的，索性写一下它们的区别和联系。 Vue提供了很多事件修饰符来辅助实现一些功能。 常见的事件修饰符有如下： .stop 阻止冒泡。本质是调用 event.stopPropagation()。 .prevent 阻止默认事件（默认行为）。本质是调用 event.preventDefault()。 .capture 添加事件监听器时，使用捕获的方式（也就是说，事件采用捕获的方式，而不是采用冒泡的方式）。 .self 只有当事件在该元素本身（比如不是子元素）触发时，才会触发回调。 .once 事件只触发一次。 注意：一个事件，允许同时使用多个事件修饰符。 这里，稍微扯一下冒泡和捕获的概念的区别。 首先，假设有这样一个场景，有一个父div容器包含了一个子div容器。 如果我们对父div容器设定了点击触发事件，同时对子div也设定了一个点击触发事件。 这时，我们由于包含关系，在默认情况下，点击子div会随之触发父div点击事件，这样的情况由于是向上一级 触发的，类似于向上冒泡的行为，所以我们称之为“冒泡”。 相反的，如果点击触发父容器事件而引发了子容器事件的触发，这种向下一级的触发的，则称之为“捕获”。 而.stop就可以实现阻止冒泡自行为的继续下去，.self也可实现该功能，但是有一个限制，就是只能在被此修饰符修饰的标签自身阻止自身被冒泡，只有点击他本身时才去执行此操作，点击他的其他关联元素不去执行此操作，也就是说，只有点击他本身才可以。而.stop是从修饰的标签所在的内外结构中，由最内层开始冒泡到，如果是。 而相反的，.capture则是从修饰的标签所在的内外结构中，由最外层开始阻止向下一级触发事件。 下面来举几个例子： (1).stop （阻止事件继续传播 即阻止它的捕获和冒泡过程）实例：如下点击内部点击，阻止了冒泡过程，即只执行tz这个方法，如果不加.stop，讲先执行方法，后执行gett方法。即通过了冒泡这个过程。 123&lt;div v-on:click=\"gett\"&gt;外部点击 &lt;div v-on:click.stop=\"tz\"&gt;内部点击&lt;/div&gt;&lt;/div&gt; （2）.prevent （阻止默认事件发生 即event.preventdefault(): ）实例： 阻止了a标签的默认刷新，点击超链接将不会实现跳转。 1&lt;a href=\"www.baidu.com\" v-on:click.prevent&gt;点击&lt;/a&gt; （3）.capture （添加事件监听器时使用事件捕获模式，即在捕获模式下触发）实例：在点击最里层的点击6时，gett方法先执行，因为gett方法在捕获模式执行的，先与冒泡事件。下列执行顺序 geet-&gt;set-&gt;tz ,因为后俩个还是冒泡模式下触发的事件。 12345&lt;div v-on:click.capture=\"gett\"&gt;外部点击5 &lt;div v-on:click=\"tz\"&gt;内部点击5 &lt;div v-on:click=\"set\"&gt;点击6&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; （4）.self （当前元素自身时触发处理函数时才会触发函数，原理：是根据event.target确定是否当前元素本身，来决定是否触发的事件/函数 ）实例：如果点击内部点击2，冒泡不会执行gett方法，因为event.target指的是内部点击2的dom元素，不是外部点击1的，所以不会触发自己的点击事件。 123&lt;div v-on:click.self=\"gett\"&gt;外部点击1 &lt;div v-on:click=\"tz\"&gt;内部点击2&lt;/div&gt;&lt;/div&gt; （5）.once （只触发一次）实例： 1&lt;div v-on:click.once=\"tz\"&gt;once&lt;/div&gt; 全部代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\" /&gt; &lt;link href=\"css/mui.min.css\" rel=\"stylesheet\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;button v-on:click=\"gett\" &gt;点击&lt;/button&gt; &lt;input type=\"text\" v-on:keyup.13=\"gett\" /&gt; &lt;div v-on:click=\"gett\"&gt;外部点击 &lt;div v-on:click.stop=\"tz\"&gt;内部点击&lt;/div&gt; &lt;/div&gt; &lt;a href=\"\" v-on:click.prevent&gt;dsfs&lt;/a&gt; &lt;div v-on:click.self=\"gett\"&gt;外部点击1 &lt;div v-on:click=\"tz\"&gt;内部点击2&lt;/div&gt; &lt;/div&gt; &lt;div v-on:click.capture=\"gett\"&gt;外部点击5 &lt;div v-on:click=\"tz\"&gt;内部点击5 &lt;div v-on:click=\"set\"&gt;点击6&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div v-on:click.once=\"tz\"&gt;once&lt;/div&gt; &lt;/div&gt; &lt;div id='a'&gt;外部点击3 &lt;div id='b'&gt;内部点击4&lt;/div&gt; &lt;/div&gt; &lt;script src=\"js/mui.min.js\"&gt;&lt;/script&gt; &lt;script src=\"js/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; mui.init() &lt;/script&gt; &lt;script type=\"application/javascript\"&gt; var app = new Vue(&#123; el: '#app', data: &#123; name:'张三' &#125;, methods:&#123; gett:function(e)&#123; alert(\"111\"); console.log(e.target); this.name='李四'; &#125;, tz:function(e)&#123; console.log(e.target); alert(222) &#125;, set:function(e)&#123; console.log(e.target); alert(333) &#125; &#125; &#125;) document.getElementById('a').addEventListener('click',function(e)&#123; console.log(e.target); alert('aaaa') &#125;,true) document.getElementById('b').addEventListener('click',function(e)&#123; console.log(e.target); alert('bbbb') &#125;,true) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","tags":[{"name":"前端框架","slug":"前端框架","permalink":"https://8bun.github.io/tags/前端框架/"},{"name":"事件修饰符","slug":"事件修饰符","permalink":"https://8bun.github.io/tags/事件修饰符/"}],"categories":[{"name":"前端","slug":"前端","permalink":"https://8bun.github.io/categories/前端/"},{"name":"Vue","slug":"前端/Vue","permalink":"https://8bun.github.io/categories/前端/Vue/"}]},{"title":"LeetCode-使用递归解决括号生成问题","date":"2019-05-06T04:20:35.000Z","path":"2019/05/06/LeetCode-使用递归解决括号生成问题/","text":"问题可见：https://leetcode.com/problems/generate-parentheses/ 描述给定n对括号，编写一个函数来生成格式正确的括号的所有组合。 例如，给定n = 3，解集是： 1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 思路： 意题的英文给你n值，让你找到所有格式正确的圆括号匹配组，中题目给出已经了n = 3的所有查询查询结果。遇到这种问题，第一直觉就是用到递归或者堆栈，我们选取递归来解决，也就是helper函数的功能，从参数上来看肯定很好理解了，leftRest代表还有几个左括号可以用，rightNeed代表还需要几个右括号才能匹配，初始状态当然是rightNeed = 0, leftRest = n，递归的终止状态就是rightNeed == 0 &amp;&amp; leftRest == 0，也就是左右括号都已匹配完毕，把然后str加入到链表中即可。 1234567891011121314151617181920212223242526272829import java.util.ArrayList;import java.util.List;//初始先有(,)是根据(的添加之后才产生的//终止条件为(和)均为空public class getList &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); public List&lt;String&gt; generateParenthesis(int n) &#123; helper(list,\"\",n,0); return list; &#125; public void helper(List&lt;String&gt; list, String str, int LeftRest,int RightNeed)&#123; //终止条件 if(LeftRest==0&amp;&amp;RightNeed==0)&#123; list.add(str); return; &#125; if(RightNeed&gt;0) &#123; helper(list, str + \")\", LeftRest, RightNeed - 1); &#125; if(LeftRest&gt;0) &#123; helper(list, str + \"(\", LeftRest - 1, RightNeed + 1); &#125; &#125; //test public static void main(String[] args) &#123; System.out.println(new getList().generateParenthesis(3)); &#125;&#125;","tags":[{"name":"递归","slug":"递归","permalink":"https://8bun.github.io/tags/递归/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://8bun.github.io/categories/LeetCode/"},{"name":"算法","slug":"LeetCode/算法","permalink":"https://8bun.github.io/categories/LeetCode/算法/"}]},{"title":"JS跨域请求服务器数据的几种实用方法","date":"2019-05-05T10:10:37.000Z","path":"2019/05/05/JS跨域请求服务器数据的几种实用方法/","text":"域与源js跨域是指通过js在不同域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据，或者说通过js获取页面中不同域的框架中(iframe)的数据。 只要协议、域名、端口有任何一个不同，都被当作是不同的域。所谓同源是指，域名，协议，端口完全相同。 而要实现跨域，我们可以使用一下几种方法： 通过JSONP跨域在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。 比如，有个a.html页面，它需要利用ajax获取一个不同域上的json数据。而这个json数据是来自http://example.com/data.php,代码如下： 123456&lt;?php //通过_GET方法获取回调函数，即请求数据客户端和服务器之间事先约定好的函数，在数据被获取之后调用的函数 $callback=$_GET['callback']; $data=array['a','b','c']; //数组// echo会输出数据，适合于php与浏览器、 javascript之间进行通信，或者不同服务器之间进行通信 echo $callback.'('+json_encode($data).')'; //\".\"为字符串拼接符，json_encode方法将data数组转化为json格式并进行转码，此处调用了回调函数 而此时a.html的代码就可以这样： 1234567&lt;script&gt; function fun(jsondata)&#123; //处理获得的json数据 &#125;&lt;/script&gt;//设置回调函数&lt;script src=\"http://example.com/data.php?callback=fun\"&gt;&lt;/script&gt; 这样jsonp的原理就很清楚了，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以jsonp是需要服务器端的页面进行相应的配合的。 知道jsonp跨域的原理后我们就可以用js动态生成script标签来进行跨域操作了，而不用特意的手动的书写那些script标签。 如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。 那样你就不用多写一个script了： 12345&lt;script&gt; $.getJSON('http://example.com/data.php?callback=?',function(jsondata)&#123; //处理获得的json数据 &#125;);&lt;/script&gt; 我们发现，以上调用的回调函数没有函数名，原理是这样的，jquery会为回调函数自动生成一个全局函数，这个函数名是随机的，这个生成的随机函数只是起一个临时代理函数的作用，随后任务完成后又会被销毁。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。 这里讲一下异步的概念： 我们在访问一个普通的网站时，当浏览器加载完HTML、CSS、JS以后，网站的内容就固定了。如果想让网站内容发生更改，就必须刷新页面才能够看到更新的内容。 可如果用到异步更新，情况就大为改观了。比如，我们在访问新浪微博时，看到一大半了，点击底部的加载更多，会自动帮我们加载更多的微博，同时页面并没有刷新。 试想一下，如果没有异步刷新的话，每次点击“加载更多”，网页都要刷新，体验就太不好了。 web前端里的异步更新，就要用到 Ajax。 同步：必须等待前面的任务完成，才能继续后面的任务。 异步：不受当前任务的影响。 拿排队举例： 同步：在银行排队时，只有等到你了，才能够去处理业务。 异步：在排队的时候，可以玩手机。 通过修改document.domain来跨子域有一个页面，它的地址是http://www.example.com/a.html ， 在这个页面里面有一个iframe，它的src是http://example.com/b.html, 很显然，这个页面与它里面的iframe框架是不同域的，如果使用 iframe（iframe对象）.currentWindow，这是可以获取到iframe的window对象的，但是该获取的对象的属性和方法几乎是不可用的。所以我们是无法通过在页面中书写js代码来获取iframe中的东西的。 这时候，document.domain就可以派上用场了。 这个时候，document.domain就可以派上用场了，我们只要把http://www.example.com/a.html 和 http://example.com/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。例如：a.b.example.com 中某个文档的document.domain 可以设成a.b.example.com、b.example.com 、example.com中的任意一个，但是不可以设成 c.a.b.example.com,因为这是当前域的子域，也不可以设成baidu.com,因为主域已经不相同了。 在页面 http://www.example.com/a.html 中设置document.domain: 12345678&lt;iframe src=\" http://www.example.com/b.html\" id=\"iframe\" onload=\"test()\"&gt; &lt;script&gt; document.domain='example.com'; //设置成主域 function test()&#123; alert(document.getElementById('iframe').contentWindow); &#125; &lt;/script&gt;&lt;/iframe&gt; 在页面 http://example.com/b.html 中也设置document.domain，而且这也是必须的，虽然这个文档的domain就是example.com,但是还是必须显示的设置document.domain的值： 123&lt;script&gt; document.domain='example.com'; &lt;/script&gt; 这样我们就可以通过js访问到iframe中的各种属性和对象了。 不过如果你想在http://www.example.com/a.html 页面中通过ajax直接请求http://example.com/b.html 页面，即使你设置了相同的document.domain也还是不行的，所以修改document.domain的方法只适用于不同子域的框架间的交互。 如果你想通过ajax的方法去与不同子域的页面交互，除了使用jsonp的方法外，还可以用一个隐藏的iframe来做一个代理。原理就是让这个iframe载入一个与你想要通过ajax获取数据的目标页面处在相同的域的页面，所以这个iframe中的页面是可以正常使用ajax去获取你要的数据的，然后就是通过我们刚刚讲得修改document.domain的方法，让我们能通过js完全控制这个iframe，这样我们就可以让iframe去发送ajax请求，然后收到的数据我们也可以获得了。 使用window.name来进行跨域window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。 比如：有一个页面a.html,它里面有这样的代码： 123456&lt;script&gt; window.name='我是页面a设置的值'; setTimeout(function()&#123; window.location='b.html'; &#125;,3000); //3秒后把一个新页面b.html载入到当前的window&lt;/script&gt; 再看看b.html页面的代码： 123&lt;script&gt; alert(window.name); &lt;/script&gt; a.html页面载入后3秒，跳转到了b.html页面，结果为： 我们看到在b.html页面上成功获取到了它的上一个页面a.html给window.name设置的值。如果在之后所有载入的页面都没对window.name进行修改的话，那么所有这些页面获取到的window.name的值都是a.html页面设置的那个值。 当然，如果有需要，其中的任何一个页面都可以对window.name的值进行修改。注意，window.name的值只能是字符串的形式，这个字符串的大小最大能允许2M左右甚至更大的一个容量，具体取决于不同的浏览器，但一般是够用了。 上面的例子中，我们用到的页面a.html和b.html是处于同一个域的，但是即使a.html与b.html处于不同的域中，上述结论同样是适用的，这也正是利用window.name进行跨域的原理。 下面就来看一看具体是怎么样通过window.name来跨域获取数据的。还是举例说明。 比如有一个www.example.com/a.html页面,需要通过a.html页面里的js来获取另一个位于不同域上的页面www.cnblogs.com/data.html里的数据。 data.html页面里的代码很简单，就是给当前的window.name设置一个a.html页面想要得到的数据值。data.html里的代码： 那么在a.html页面中，我们怎么把data.html页面载入进来呢？显然我们不能直接在a.html页面中通过改变window.location来载入data.html页面，因为我们想要即使a.html页面不跳转也能得到data.html里的数据。答案就是在a.html页面中使用一个隐藏的iframe来充当一个中间人角色，由iframe去获取data.html的数据，然后a.html再去得到iframe获取到的数据。 充当中间人的 iframe 想要获取到data.html的通过window.name设置的数据，只需要把这个iframe的src设为www.cnblogs.com/data.html就行了。然后a.html想要得到iframe所获取到的数据，也就是想要得到iframe的window.name的值，还必须把这个iframe的src设成跟a.html页面同一个域才行，不然根据前面讲的同源策略，a.html是不能访问到iframe里的window.name属性的。这就是整个跨域过程。 看下a.html页面的代码： 上面的代码只是最简单的原理演示代码，你可以对使用js封装上面的过程，比如动态的创建iframe,动态的注册各种事件等等，当然为了安全，获取完数据后，还可以销毁作为代理的iframe。网上也有很多类似的现成代码，有兴趣的可以去找一下。 通过window.name来进行跨域，就是这样子的。 使用HTML5中新引进的window.postMessage方法来跨域传送数据window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。 调用postMessage方法的对象为消息发送方的window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；第二个参数targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 * 。 需要接收消息的window对象，可是通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。 上面所说的向其他window对象发送消息，其实就是指一个页面有几个框架的那种情况，因为每一个框架都有一个window对象。在讨论第二种方法的时候，我们说过，不同域的框架间是可以获取到对方的window对象的，而且也可以使用window.postMessage这个方法。 下面看一个简单的示例，有两个页面。a.html中加载了b.html中的一个 iframe ，并加载页面的时候来自a.html中的iframe对象所绑定的window对象调用了发送了消息，而且接收方不限定域。这时在b.html页面中就可以获取数据了。 我们运行a页面后得到的结果: 我们看到b页面成功的收到了消息。 使用postMessage来跨域传送数据还是比较直观和方便的，但是缺点是IE6、IE7不支持，所以用不用还得根据实际需要来决定。 结语： 除了以上几种方法外，还有flash、在服务器上设置代理页面等跨域方式，这里就不做介绍了。 以上四种方法，可以根据项目的实际情况来进行选择应用，个人认为window.name的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。 本文感谢：https://www.cnblogs.com/2050/p/3191744.html 的帮助^_^","tags":[{"name":"服务器","slug":"服务器","permalink":"https://8bun.github.io/tags/服务器/"},{"name":"JS","slug":"JS","permalink":"https://8bun.github.io/tags/JS/"},{"name":"请求数据","slug":"请求数据","permalink":"https://8bun.github.io/tags/请求数据/"},{"name":"跨域","slug":"跨域","permalink":"https://8bun.github.io/tags/跨域/"}],"categories":[{"name":"JS跨域请求","slug":"JS跨域请求","permalink":"https://8bun.github.io/categories/JS跨域请求/"}]},{"title":"Java多线程","date":"2019-04-29T04:37:54.000Z","path":"2019/04/29/Java多线程/","text":"优势 多个线程可以共享内存，而进程间不能共享内存，进程的创建需要重新分配系统资源，但创建线程的代价则小得多 实际应用 一个浏览器能同时下载多个图片 一个Web服务器能同时响应多个用户请求 Java虚拟机本身就在后台提供了一个超级线程来进行垃圾回收 图形用户界面（GUI）也需要启动一个单独的线程来从主机环境中收集用户界面事件 and so on 使用继承Thread和实现Runnable接口两种方式创建线程的对比 实现Runnable接口方式： 线程类还可继承其他类 需使用 Thread. currentThread () 访问当前线程 避免了单继承的局限性、多个线程可以共享一个target对象，非常适合多线程处理同一份资源的情形。 继承Thread的方式： 不能再继承其他父类 可直接使用 this 访问当前线程","tags":[{"name":"Java","slug":"Java","permalink":"https://8bun.github.io/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"https://8bun.github.io/tags/多线程/"}],"categories":[{"name":"多线程","slug":"多线程","permalink":"https://8bun.github.io/categories/多线程/"}]},{"title":"JQuery相关事宜","date":"2019-04-28T12:16:40.000Z","path":"2019/04/28/JQuery相关事宜/","text":"引入 jQuery 的原因在用 js 写代码时，会遇到一些问题： window.onload 事件有事件覆盖的问题，因此只能写一个事件。 代码容错性差。 浏览器兼容性问题。 书写很繁琐，代码量多。 代码很乱，各个页面到处都是。 动画效果很难实现。 如下图所示： jQuery的出现，可以解决以上问题。 什么是 jQueryjQuery 是 js 的一个库，封装了我们开发过程中常用的一些功能，方便我们调用，提高开发效率。 js库是把我们常用的功能放到一个单独的文件中，我们用的时候，直接引用到页面里即可。 以下是jQuery的相关信息： 官网：http://jquery.com/ 官网API文档：http://api.jquery.com/ 中文汉化API文档：http://www.css88.com/jqapi-1.9/ 学习jQuery，主要是学什么初期，主要学习如何使用jQuery操作DOM，其实就是学习jQuery封装好的那些API。 这些API的共同特点是：几乎全都是方法。所以，在使用jQuery的API时，都是方法调用，也就是说要加小括号()，小括号里面是相应的参数，参数不同，功能不同。 jQuery初体验现在用原生 js 来写下面这一段代码： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div &#123; height: 100px; background-color: pink; margin: 10px; display: none; &#125; &lt;/style&gt; &lt;script&gt; //原生js window.onload = function () &#123; var btn = document.getElementsByTagName(\"button\")[0]; var divArr = document.getElementsByTagName(\"div\"); btn.onclick = function () &#123; for (var i = 0; i &lt; divArr.length; i++) &#123; divArr[i].style.display = \"block\"; divArr[i].innerHTML = \"生命壹号\"; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;显示五个div盒子和设置内容&lt;/button&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 如果用 jQuery 来写，保持其他的代码不变，&lt;script&gt;部分的代码修改为：（需要提前引入 ） 123456789101112131415161718&lt;script src=\"jquery-1.11.1.js\"&gt;&lt;/script&gt;&lt;script&gt; //jquery版 $(document).ready(function () &#123; //获取元素 var jQbtn = $(\"button\");//根据标签名获取元素 var jQdiv = $(\"div\");//根据标签名获取元素 //绑定事件 jQbtn.click(function () &#123; jQdiv.show(1000);//显示盒子。 jQdiv.html(\"tomorrow！\");//设置内容 //上面的两行可以写成链式编程：jQdiv.show(3000).html(1111); &#125;);//事件是通过方法绑定的。 &#125;);&lt;/script&gt; jQuery 的两大特点（1）链式编程：比如.show()和.html()可以连写成.show().html()。 链式编程原理：return this。 通常情况下，只有设置操作才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 this。 （2）隐式迭代：隐式 对应的是 显式。隐式迭代的意思是：在方法的内部会为匹配到的所有元素进行循环遍历，执行相应的方法；而不用我们再进行循环，简化我们的操作，方便我们调用。 如果获取的是多元素的值，大部分情况下返回的是第一个元素的值。 jQuery 的使用使用 jQuery 的基本步骤（1）引包 （2）入口函数 （3）功能实现代码（事件处理） 如下图所示： 主要，导包的代码一定要放在js代码的最上面。 jQuery 的版本jQuery 有两个大版本： 1.x版本：最新版为 v1.11.3。 2.x版本：最新版为 v2.1.4（不再支持IE6、7、8）。 3.x版本。 PS：开发版本一般用1.10以上。 我们以 v1.11.1版本为例，下载下来后发现，里面有两个文件： 它们的区别是： 第一个是未压缩版，第二个是压缩版。 平时开发过程中，可以使用任意一个版本；但是，项目上线的时候，推荐使用压缩版。 jQuery 的入口函数和 `## 符号入口函数（重要）原生 js 的入口函数指的是：window.onload = function() {}; 如下： 12345 //原生 js 的入口函数。页面上所有内容加载完毕，才执行。 //不仅要等文本加载完毕，而且要等图片也要加载完毕，才执行函数。window.onload = function () &#123; alert(1);&#125; 而 jQuery的入口函数，有以下几种写法： 写法一： 1234//1.文档加载完毕，图片不加载的时候，就可以执行这个函数。$(document).ready(function () &#123; alert(1);&#125;) 写法二：（写法一的简洁版） 1234//2.文档加载完毕，图片不加载的时候，就可以执行这个函数。$(function () &#123; alert(1);&#125;); 写法三： 1234//3.文档加载完毕，图片也加载完毕的时候，在执行这个函数。$(window).ready(function () &#123; alert(1);&#125;) jQuery入口函数与js入口函数的区别： 区别一：书写个数不同： Js 的入口函数只能出现一次，出现多次会存在事件覆盖的问题。 jQuery 的入口函数，可以出现任意多次，并不存在事件覆盖问题。 区别二：执行时机不同： Js的入口函数是在所有的文件资源加载完成后，才执行。这些文件资源包括：页面文档、外部的js文件、外部的css文件、图片等。 jQuery的入口函数，是在文档加载完成后，就执行。文档加载完成指的是：DOM树加载完成后，就可以操作DOM了，不用等到所有的外部资源都加载完成。 文档加载的顺序：从上往下，边解析边执行。 jQuery的`### 符号jQuery 使用 $ 符号原因：书写简洁、相对于其他字符与众不同、容易被记住。 jQuery占用了我们两个变量：$ 和 jQuery。当我们在代码中打印它们俩的时候： 123456789&lt;script src=\"jquery-1.11.1.js\"&gt;&lt;/script&gt;&lt;script&gt; console.log($); console.log(jQuery); console.log($===jQuery);&lt;/script&gt; 打印结果如下： 从打印结果可以看出，$ 代表的就是 jQuery。 那怎么理解jQuery里面的 $ 符号呢？ $ 实际上表示的是一个函数名 如下： 123456789$(); // 调用上面我们自定义的函数$$(document）.ready(function()&#123;&#125;); // 调用入口函数$(function()&#123;&#125;); // 调用入口函数$(“#btnShow”) // 获取id属性为btnShow的元素$(“div”) // 获取所有的div标签元素 如上方所示，jQuery 里面的 $ 函数，根据传入参数的不同，进行不同的调用，实现不同的功能。返回的是jQuery对象。 jQuery这个js库，除了$ 之外，还提供了另外一个函数：jQuery。jQuery函数跟 ` 函数的关系：`jQuery ===。 js中的DOM对象 和 jQuery对象 比较（重点，难点）二者的区别通过 jQuery 获取的元素是一个数组，数组中包含着原生JS中的DOM对象。举例： 针对下面这样一个div结构： 12345&lt;div&gt;&lt;/div&gt;&lt;div class=\"box\"&gt;&lt;/div&gt;&lt;div id=\"box\"&gt;&lt;/div&gt;&lt;div class=\"box\"&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt; 通过原生 js 获取这些元素节点的方式是： 123var myBox = document.getElementById(\"box\"); //通过 id 获取单个元素var boxArr = document.getElementsByClassName(\"box\"); //通过 class 获取的是数组var divArr = document.getElementsByTagName(\"div\"); //通过标签获取的是数组 通过 jQuery 获取这些元素节点的方式是：（获取的都是数组） 1234//获取的是数组，里面包含着原生 JS 中的DOM对象。var jqBox1 = $(\"#box\");var jqBox2 = $(\".box\");var jqBox3 = $(\"div\"); 我们打印出来看看： 上图显示，由于JQuery 自带了 css()方法，我们还可以直接在代码中给 div 设置 css 属性。 总结：jQuery 就是把 DOM 对象重新包装了一下，让其具有了 jQuery 方法。 二者的相互转换1、 DOM 对象 转为 jQuery对象： 1$(js对象); 举例：（拿上一段的代码举例） 1234//转换。jqBox1 = $(myBox);jqBox2 = $(boxArr);jqBox3 = $(divArr); DOM 对象转换成了 jquery 对象之后，上面的功能可以直接调用。 2、jQuery对象 转为 DOM 对象： 123jquery对象[index]; //方式1（推荐）jquery对象.get(index); //方式2 jQuery对象转换成了 DOM 对象之后，可以直接调用 DOM 提供的一些功能。如： 123//jquery对象转换成 DOM 对象之后jqBox3[0].style.backgroundColor = \"black\";jqBox3.get(4).style.backgroundColor = \"pink\"; 总结：如果想要用哪种方式设置属性或方法，必须转换成该类型。 举例：隔行变色代码如下： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"jquery-1.11.1.js\"&gt;&lt;/script&gt; &lt;script&gt; //入口函数 jQuery(function () &#123; var jqLi = $(\"li\"); for (var i = 0; i &lt; jqLi.length; i++) &#123; if (i % 2 === 0) &#123; //jquery对象，转换成了js对象 jqLi[i].style.backgroundColor = \"pink\"; &#125; else &#123; jqLi[i].style.backgroundColor = \"yellow\"; &#125; &#125; &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： jQuery 选择器我们以前在CSS中学习的选择器有： 今天来学习一下jQuery 选择器。 jQuery选择器是jQuery强大的体现，它提供了一组方法，让我们更加方便的获取到页面中的元素。 1、jQuery 的基本选择器 解释如下： 举例： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"jquery-1.11.1.js\"&gt;&lt;/script&gt; &lt;script&gt; //入口函数 jQuery(document).ready(function () &#123; //三种方式获取jquery对象 var jqBox1 = $(\"#box\"); var jqBox2 = $(\".box\"); var jqBox3 = $(\"div\"); //操作标签选择器 jqBox3.css(\"width\", 100); jqBox3.css(\"height\", 100); jqBox3.css(\"margin\", 10); jqBox3.css(\"background\", \"pink\"); //操作类选择器(隐式迭代，不用一个一个设置) jqBox2.css(\"background\", \"red\"); //操作id选择器 jqBox1.css(\"background\", \"yellow\"); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;div class=\"box\"&gt;&lt;/div&gt;&lt;div id=\"box\"&gt;&lt;/div&gt;&lt;div class=\"box\"&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 2、层级选择器 解释如下： 举例： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"jquery-1.11.1.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; //获取ul中的li设置为粉色 //后代：儿孙重孙曾孙玄孙.... var jqLi = $(\"ul li\"); jqLi.css(\"margin\", 5); jqLi.css(\"background\", \"pink\"); //子代：亲儿子 var jqOtherLi = $(\"ul&gt;li\"); jqOtherLi.css(\"background\", \"red\"); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;ol&gt; &lt;li&gt;aaa&lt;/li&gt; &lt;li&gt;bbb&lt;/li&gt; &lt;li&gt;ccc&lt;/li&gt; &lt;/ol&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 效果： 3、基本过滤选择器 解释： 举例： 1234567891011121314151617181920212223242526&lt;script src=\"jquery-1.11.1.js\"&gt;&lt;/script&gt;&lt;script&gt; $(document).ready(function () &#123; // :odd $(\"li:odd\").css(\"background\", \"red\"); // :even $(\"li:even\").css(\"background\", \"green\"); // :eq(index) $(\"ul li:eq(3)\").css(\"font-size\", \"30px\"); //设置第四个li的字体 // :lt(index) $(\"li:lt(6)\").css(\"font-size\", \"30px\"); // :gt(index) $(\".ulList1 li:gt(7)\").css(\"font-size\", \"40px\"); // :first $(\".ulList li:first\").css(\"font-size\", \"40px\"); // :last $(\"li:last\").css(\"font-size\", \"40px\"); &#125;);&lt;/script&gt; 4、属性选择器 5、筛选选择器 举例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"jquery-1.11.1.js\"&gt;&lt;/script&gt; &lt;script&gt; jQuery(function () &#123; var jqul = $(\"ul\"); //find(selector); 从jquery对象的后代中查找 //必须制定参数，如果不指定获取不到元素。length === 0 jqul.find(\"li\").css(\"background\", \"pink\"); console.log(jqul.find()); //chidlren(selector); 从jquery对象的子代中查找 //不写参数代表获取所有子元素。 jqul.children(\"li\").css(\"background\", \"green\"); //eq(索引值); 从jquery对象的子代中查找该索引值的元素 //要写该数组中的第几个。 jqul.children().eq(0).css(\"background\", \"red\"); //next(); 该元素的下一个兄弟元素 jqul.children().eq(0).next().css(\"background\", \"yellow\"); //siblings(selector); 该元素的所有兄弟元素 jqul.children().eq(0).next().siblings().css(\"border\", \"1px solid blue\"); //parent(); 该元素的父元素（和定位没有关系） console.log(jqul.children().eq(0).parent()); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li class=\"box\"&gt;生命壹号，永不止步&lt;/li&gt; &lt;span&gt;生命壹号，永不止步&lt;/span&gt; &lt;li class=\"box\"&gt;生命壹号，永不止步&lt;/li&gt; &lt;i&gt;生命壹号，永不止步&lt;/i&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;a id=\"box\" href=\"#\"&gt;生命壹号，永不止步&lt;/a&gt; &lt;ol&gt; &lt;li&gt;我是ol中的li&lt;/li&gt; &lt;li&gt;我是ol中的li&lt;/li&gt; &lt;li&gt;我是ol中的li&lt;/li&gt; &lt;li&gt;我是ol中的li&lt;/li&gt; &lt;/ol&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 效果： 举例举例1：鼠标悬停时，弹出下拉菜单【重要】完整版代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; list-style: none; &#125; .wrap &#123; width: 330px; height: 30px; margin: 100px auto 0; padding-left: 10px; background-color: pink; &#125; .wrap li &#123; background-color: yellowgreen; &#125; .wrap &gt; ul &gt; li &#123; float: left; margin-right: 10px; position: relative; &#125; .wrap a &#123; display: block; height: 30px; width: 100px; text-decoration: none; color: #000; line-height: 30px; text-align: center; &#125; .wrap li ul &#123; position: absolute; top: 30px; display: none; &#125; &lt;/style&gt; &lt;script src=\"jquery-1.11.1.js\"&gt;&lt;/script&gt; &lt;script&gt; //入口函数 $(document).ready(function () &#123; //需求：鼠标放入一级li中，让他里面的ul显示。移开隐藏。 var jqli = $(\".wrap&gt;ul&gt;li\"); //绑定事件 jqli.mouseenter(function () &#123; //这个位置用到了this. // console.log(this); //打印结果是js中的dom对象。注意：jquery对象绑定的事件中，this指js中的dom对象。【重要】 //让this中的ul显示出来。// 原生 js 的做法是：this.children[1].style.display = \"block\"; //把js的dom对象包装为jquery对象，然后用jquery方法操作 $(this).children(\"ul\").show(); &#125;); //绑定事件：鼠标移开时，隐藏下拉菜单 jqli.mouseleave(function () &#123; $(this).children(\"ul\").hide(); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"wrap\"&gt; &lt;ul&gt; &lt;li&gt; &lt;a href=\"javascript:void(0);\"&gt;一级菜单1&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"javascript:void(0);\"&gt;二级菜单1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:void(0);\"&gt;二级菜单2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:void(0);\"&gt;二级菜单3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"javascript:void(0);\"&gt;一级菜单1&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"javascript:void(0);\"&gt;二级菜单1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:void(0);\"&gt;二级菜单2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:void(0);\"&gt;二级菜单3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=\"javascript:void(0);\"&gt;一级菜单1&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"javascript:void(0);\"&gt;二级菜单1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:void(0);\"&gt;二级菜单2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:void(0);\"&gt;二级菜单3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上方代码中，我们可以看到，用 jQuery来操作，是非常方便的。 实现效果如下： this的用法： 上方代码中，核心的一行代码是： 123$(this).children(\"ul\").show();$(this).children(\"ul\").hide(); 如果我把这行代码中的this直接写成 DOM对象： 123jqli.children(\"ul\").show();jqli.children(\"ul\").hide(); 产生的结果是：（不是我们期望的结果） 两张图的对比，可以看出this的作用：谁正在调用函数，this就指的是谁。 举例2：鼠标悬停时变色完整版代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src=\"jquery-1.11.1.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; //需求；隔行变色；鼠标悬停时，还要变色。 var jqli1 = $(\"li:odd\"); var jqli2 = $(\"li:even\"); jqli1.css(\"background\", \"#cccccc\"); jqli2.css(\"background\", \"white\"); //鼠标悬停时变色 var color = \"\"; $(\"li\").mouseenter(function () &#123; color = $(this).css(\"background\"); //先把之前的颜色保存下来，鼠标离开时还原 $(this).css(\"background\", \"green\"); &#125;); //鼠标离开时，恢复为原来的颜色 $(\"li\").mouseleave(function () &#123; $(this).css(\"background\", color); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt; &lt;li&gt;生命壹号，永不止步&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 效果如下： 举例3：突出显示要求：鼠标悬停时，突出显示这个li，让其他的li都半透明。 用 jQuery的选择起来实现，会发现非常方便。 完整版代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; list-style: none; &#125; body &#123; background: #000; &#125; .wrap &#123; margin: 100px auto 0; width: 630px; height: 394px; padding: 10px 0 0 10px; background: #000; overflow: hidden; border: 1px solid #fff; &#125; .wrap li &#123; float: left; margin: 0 10px 10px 0; &#125; .wrap img &#123; display: block; border: 0; &#125; &lt;/style&gt; &lt;script src=\"jquery-1.11.1.js\"&gt;&lt;/script&gt; &lt;script&gt; jQuery(window).ready(function () &#123; //需求：鼠标放入li中，其他的li半透明，当前盒子的opacity值为1 $(\".wrap\").find(\"li\").mouseenter(function () &#123; //链式编程 $(this).css(\"opacity\", 1).siblings(\"li\").css(\"opacity\", 0.4); &#125;); //离开wrap的时候所有的li的全部opacity值为1； $(\".wrap\").mouseleave(function () &#123; $(this).children().children(\"li\").css(\"opacity\", 1);// $(\".wrap li\").css(\"opacity\",1); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"wrap\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/01.jpg\" alt=\"\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/02.jpg\" alt=\"\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/03.jpg\" alt=\"\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/04.jpg\" alt=\"\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/05.jpg\" alt=\"\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/06.jpg\" alt=\"\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 实现的效果： 注意这里的css布局里，每一个图片都用一个li来存放。设置li的父亲的宽度之后，然后将li设置为浮动，即可自适应地排列成两排。 工程文件： 2018-02-05-突出显示.rar 举例4：手风琴效果完整版代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; * &#123;padding: 0;margin: 0;&#125; ul &#123; list-style-type: none;&#125; .parentWrap &#123; width: 200px; text-align:center; &#125; .menuGroup &#123; border:1px solid #999; background-color:#e0ecff; &#125; .groupTitle &#123; display:block; height:20px; line-height:20px; font-size: 16px; border-bottom:1px solid #ccc; cursor:pointer; &#125; .menuGroup &gt; div &#123; height: 200px; background-color:#fff; display:none; &#125; &lt;/style&gt; &lt;script src=\"jquery-1.11.1.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; //需求：鼠标点击span，让他下面的div显示出来。让其他的div隐藏。 $(\".parentWrap span\").click(function () &#123;// $(this).next().show();// //让其他的隐藏// //点击的span的父亲li，的所有的兄弟元素li，的孩子元素div全部隐藏。// $(this).parent(\"li\").siblings(\"li\").children(\"div\").hide(); //连式编程 $(this).next().show().parent(\"li\").siblings(\"li\").find(\"div\").hide(); &#125;); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul class=\"parentWrap\"&gt; &lt;li class=\"menuGroup\"&gt; &lt;span class=\"groupTitle\"&gt;标题1&lt;/span&gt; &lt;div&gt;我是弹出来的div1&lt;/div&gt; &lt;/li&gt; &lt;li class=\"menuGroup\"&gt; &lt;span class=\"groupTitle\"&gt;标题2&lt;/span&gt; &lt;div&gt;我是弹出来的div2&lt;/div&gt; &lt;/li&gt; &lt;li class=\"menuGroup\"&gt; &lt;span class=\"groupTitle\"&gt;标题3&lt;/span&gt; &lt;div&gt;我是弹出来的div3&lt;/div&gt; &lt;/li&gt; &lt;li class=\"menuGroup\"&gt; &lt;span class=\"groupTitle\"&gt;标题4&lt;/span&gt; &lt;div&gt;我是弹出来的div4&lt;/div&gt; &lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 效果： 注意这里的 选择器的用法：parent、next 举例5：淘宝精品服饰广告完整版代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style type=\"text/css\"&gt; * &#123; margin: 0; padding: 0; font-size: 12px; &#125; ul &#123; list-style: none; &#125; a &#123; text-decoration: none; &#125; .wrapper &#123; width: 298px; height: 248px; margin: 100px auto 0; border: 1px solid pink; overflow: hidden; &#125; #left, #center, #right &#123; float: left; &#125; #left li, #right li &#123; background: url(images/lili.jpg) repeat-x; &#125; #left li a, #right li a &#123; display: block; width: 48px; height: 27px; border-bottom: 1px solid pink; line-height: 27px; text-align: center; color: black; &#125; #left li a:hover, #right li a:hover &#123; background-image: url(images/abg.gif); &#125; #center &#123; border-left: 1px solid pink; border-right: 1px solid pink; &#125; &lt;/style&gt; &lt;script src=\"jquery-1.11.1.js\"&gt;&lt;/script&gt; &lt;script&gt; jQuery(function () &#123; //需求：鼠标放入两侧的li中，让中间的ul中对应索引值的li显示出来，其他的隐藏。（右侧的li要+9） //左侧先绑。获取绑mouseenter $(\"#left li\").mouseenter(function () &#123; //显示对应索引值的中间的li //alert($(this).index()); 获取索引值 $(\"#center li\").eq($(this).index()).show().siblings(\"li\").hide(); &#125;); //右侧 $(\"#right li\").mouseenter(function () &#123; //显示对应索引值的中间的li //alert($(this).index()); 获取索引值 $(\"#center li:eq(\" + ($(this).index() + 9) + \")\").show().siblings(\"li\").hide(); &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"wrapper\"&gt; &lt;ul id=\"left\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;女靴&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;雪地靴&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;冬裙&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;呢大衣&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;毛衣&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;棉服&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;女裤&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;羽绒服&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;牛仔裤&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul id=\"center\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/女靴.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/雪地靴.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/冬裙.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/呢大衣.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/毛衣.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/棉服.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/女裤.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/羽绒服.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/牛仔裤.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/女包.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/男包.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/登山鞋.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/皮带.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/围巾.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/皮衣.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/男毛衣.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/男棉服.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&lt;img src=\"images/男靴.jpg\" width=\"200\" height=\"250\"/&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul id=\"right\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;女包&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;男包&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;登山鞋&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;皮带&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;围巾&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;皮衣&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;男毛衣&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;男棉服&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;男靴&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 效果：","tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://8bun.github.io/tags/JQuery/"}],"categories":[{"name":"前端","slug":"前端","permalink":"https://8bun.github.io/categories/前端/"}]},{"title":"KNN And K-means Algorithm","date":"2019-04-22T07:46:11.000Z","path":"2019/04/22/KNN-And-K-means-Algorithm/","text":"K-means方法是一种非监督学习的算法，它解决的是聚类问题。 1、算法简介：K-means方法是聚类中的经典算法，数据挖掘十大经典算法之一；算法接受参数k,然后将事先输入的n个数据对象划分为k个聚类以便使得所获得的聚类满足聚类中的对象相似度较高，而不同聚类中的对象相似度较小。 2、算法思想：以空间中k个点为中心进行聚类，对最靠近他们的对象归类，通过迭代的方法，逐次更新各聚类中心的值，直到得到最好的聚类结果。 3、算法描述： （1）适当选择c个类的初始中心；（2）在第k次迭代中，对任意一个样本，求其到c各中心的距离，将该样本归到距离最短的那个中心所在的类；（3）利用均值等方法更新该类的中心值；（4）对于所有的C个聚类中心，如果利用（2）（3）的迭代法更新后，值保持不变，则迭代结束；否则继续迭代。 4、算法举例： 我们假设药物A、B、C、D有两个特征值，分别是药物重量以及PH值。 药物名称 药物重量 药物PH值 A 1 1 B 2 1 C 4 3 D 5 4 现在我们要对这四个药物进行聚类，已知我们要分成两类，那么我们该怎么做呢？ 首先我们把上面的数据画到二位坐标系当中 A(1,1),B(2,1),C(4,3),D(5,4): 初始时，由于假设K=2 (表示将所有数据集分为两组，我们称之为聚类) 我们先假设药物A为聚类1的中心点，B为聚类2的中心点。那么初始时的中心坐标分别为c1=(1,1),c2=(2,1)c1=(1,1),c2=(2,1)，矩阵D的第一行代表各个点到中心点c1的距离，第二行代表各个点到中心点c2的距离；那么初始矩阵D0表示成如下： D0 = \\left[ \\begin{matrix} 0 & 1 & 3.61 & 5\\\\ 1 & 0 & 2.83 & 4.24 \\end{matrix} \\right]矩阵 D0向我们展示了除了中心点之外的其他所有点距离K个中心点的距离大小，每个点距离各个中心点的距离都不尽相同。所谓近水楼台先得月，所以将点归入离点最近的中心点一类。以后每开始一次的迭代，都会重新算出每个聚类的中心点，然后根据相同的操作进行点的归类，直到聚类中心不再进行大范围移动或者聚类次数达到要求为止。矩阵G0代表样本应该归属于哪个聚类，第一行代表各个点是否属于中心c1所在的类（0代表不在，1代表在），第二行代表各个点是否属于中心c2所在的类（0代表不在，1代表在）；那么此时G0表示成如下： G0 = \\left[ \\begin{matrix} 1 & 0 & 0 & 0\\\\ 0 & 1 & 1 & 1 \\end{matrix} \\right]由矩阵D0可知A药物属于一个类，B、C、D属于一类；然后，利用均值等方法更新该类的中心值。c1=（1,1）c2=（(2+4+5)/3,(1+3+4)/3）= (13/3,8/3) 上图是更新后的坐标图，对应的中心点也发生了变化。因为中心点跟上次不一样了，所以我们又可以对样本点进行重新划分。划分的方法还是跟以前一模一样，我们先计算出矩阵D1表示成如下： D1 = \\left[ \\begin{matrix} 0 & 1 & 3.61 & 5\\\\ 3.14 & 2.36 & 0.47 & 1.89 \\end{matrix} \\right]此时G1表示成如下： G1 = \\left[ \\begin{matrix} 1 & 1 & 0 & 0\\\\ 0 & 0 & 1 & 1 \\end{matrix} \\right]由矩阵G1可知A、B药物属于一个类，C、D属于一类；然后，利用均值等方法再次更新该类的中心值。c1=（(1+2)/2,(1+1)/2）=(1.5,1)c2=（(4+5)/2,(3+4)/2）=(4.5,3.5) 上图是更新后的坐标图，对应的中心点也发生了变化。 因为中心点跟上次不一样了，所以我们又可以对样本点进行重新划分。划分的方法还是跟以前一模一样，我们先计算出矩阵D2表示成如下： D2 = \\left[ \\begin{matrix} 0.5 & 0.5 & 3.20 & 4.61\\\\ 4.30 & 3.54 & 0.71 & 0.71 \\end{matrix} \\right]此时G2表示成如下： G2 = \\left[ \\begin{matrix} 1 & 1 & 0 & 0\\\\ 0 & 0 & 1 & 1 \\end{matrix} \\right]由矩阵G2可知A、B药物属于一个类，C、D属于一类；然后，利用均值等方法再次更新该类的中心值。c1=（(1+2)/2,(1+1)/2）=(1.5,1)c2=（(4+5)/2,(3+4)/2）=(4.5,3.5)因为对应的中心点并没有发生变化，所以迭代停止，计算完毕。本算法的时间复杂度：O(tkmn)，其中，t为迭代次数，k为簇的数目，m为记录数，n为维数； 空间复杂度：O((m+k)n)，其中，k为簇的数目，m为记录数，n为维数。 适用范围: K-means算法试图找到使平凡误差准则函数最小的簇。当潜在的簇形状是凸面的，簇与簇之间区别较明显，且簇大小相近时，其聚类结果较理想。前面提到，该算法时间复杂度为O(tkmn)，与样本数量线性相关，所以，对于处理大数据集合，该算法非常高效，且伸缩性较好。但该算法除了要事先确定簇数K和对初始聚类中心敏感外，经常以局部最优结束，同时对“噪声”和孤立点敏感，并且该方法不适于发现非凸面形状的簇或大小差别很大的簇。缺点： 1、聚类中心的个数K 需要事先给定，但在实际中这个 K 值的选定是非常难以估计的，很多时候，事先并不知道给定的数据集应该分成多少个类别才最合适；2、K-means需要人为地确定初始聚类中心，不同的初始聚类中心可能导致完全不同的聚类结果。（可以使用K-means++算法来解决）K-means 算法代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import numpy as npfrom matplotlib import pyplotclass K_Means(object): # k是分组数；tolerance为'中心点误差'；max_iter是最大迭代次数 # 类构造方法 def __init__(self, k=2, tolerance=0.0001, max_iter=300): self.k_ = k self.tolerance_ = tolerance self.max_iter_ = max_iter def fit(self, data): self.centers_ = &#123;&#125; # 中心点集合 for i in range(self.k_): self.centers_[i] = data[i] for i in range(self.max_iter_): self.clf_ = &#123;&#125; # 定义为字典，每一类都有一个名称 for i in range(self.k_): self.clf_[i] = [] # 聚类字典，根据k组数确定最大长度 # print(\"此时的中心点集合: \",self.centers_) # 遍历样本所有点 for feature in data: # distances = [np.linalg.norm(feature-self.centers[center]) for center in self.centers] distances = [] # 对每个样本点，遍历所有中心点，计算它与每个聚类的中心的距离，然后取最小距离进行归类 for center in self.centers_: # 欧拉距离 # 可使用np.sqrt(np.sum((features-self.centers_[center])**2))计算距离 # norm()可以直接计算出距离 distances.append(np.linalg.norm(feature - self.centers_[center])) # 在distances中取最小距离 classification = distances.index(min(distances)) # 返回最小距离在distances数组中的下标 self.clf_[classification].append(feature) # 将点加入clf_数组相应位置 # print(\"分组情况:\",self.clf_) prev_centers = dict(self.centers_) # 复制centers_字典 # print(prev_centers) # &#123;0: array([1., 2.]), 1: array([1.5, 1.8])&#125; → &#123;0: array([1., 2.]), 1: array([4.9 , 5.88])&#125; # print(self.clf_) # &#123;0: [array([1., 2.])],1: [array([1.5, 1.8]), array([5., 8.]), array([8., 8.]), array([1., 0.6]), array([9., 11.])]&#125; # &#123;0: [array([1., 2.]), array([1.5, 1.8]), array([1., 0.6])],1: [array([5., 8.]), array([8., 8.]), array([9., 11.])]&#125; # &#123;0: [array([1., 2.]), array([1.5, 1.8]), array([1., 0.6])],1: [array([5., 8.]), array([8., 8.]), array([9., 11.])]&#125; # 根据聚类名遍历每个聚类 for c in self.clf_: # print(c) 0 1 # 取每个聚类的均值作为正在遍历的类的新中心点，axis=0为二维数组纵向取均值 self.centers_[c] = np.average(self.clf_[c], axis=0) # '中心点'是否在误差范围 optimized = True # 根据聚类名遍历每个聚类 # print(\"prev\") # print(prev_centers) # # print(\"centers\") # print(self.centers_) for center in self.centers_: org_centers = prev_centers[center] cur_centers = self.centers_[center] # 比较类上次的中心点以及本次计算的中心点的差值，计算偏差 if np.sum((cur_centers - org_centers) / org_centers * 100.0) &gt; self.tolerance_: optimized = False if optimized: break # 预测数据所属的聚类，根据所测点距中心点的大小进行判定 def predict(self, p_data): distances = [np.linalg.norm(p_data - self.centers_[center]) for center in self.centers_] index = distances.index(min(distances)) return indexif __name__ == '__main__': x = np.array([[1, 2], [1.5, 1.8], [5, 8], [8, 8], [1, 0.6], [9, 11]]) k_means = K_Means(k=2) k_means.fit(x) # 打印最终的中心点 # print(k_means.centers_) # &#123;0: array([1.16666667, 1.46666667]), 1: array([7.33333333, 9. ])&#125; for center in k_means.centers_: # 将最终的中心点使用五角星标志出来 pyplot.scatter(k_means.centers_[center][0], k_means.centers_[center][1], marker='*', s=150) # 遍历每个聚类的所有点 for cat in k_means.clf_: for point in k_means.clf_[cat]: pyplot.scatter(point[0], point[1], c=('r' if cat == 0 else 'b')) # 预测数据 predict = [[2, 1], [6, 9]] for feature in predict: # 获取聚类所在的下标 cat = k_means.predict(predict) # 参数依次为坐标x,y,使用字母代号表示的颜色，以及显示的样式（为x表示是x号） pyplot.scatter(feature[0], feature[1], c=('r' if cat == 0 else 'b'), marker='x') pyplot.show() 执行结果： K-Means算法需要你指定K值，也就是需要人为指定数据应该分为几组。下一帖我会实现Mean Shift算法，它也是一种聚类算法(Hierarchical)，和K-Means(Flat)不同的是它可以自动判断数据集应该分为几组。 在实际数据上应用K-Means算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import numpy as npfrom sklearn.cluster import KMeansfrom sklearn import preprocessingimport pandas as pd '''数据集：titanic.xls(泰坦尼克号遇难者/幸存者名单)&lt;http://blog.topspeedsnail.com/wp-content/uploads/2016/11/titanic.xls&gt;***字段***pclass: 社会阶层(1，精英；2，中产；3，船员/劳苦大众)survived: 是否幸存name: 名字sex: 性别age: 年龄sibsp: 哥哥姐姐个数parch: 父母儿女个数ticket: 船票号fare: 船票价钱cabin: 船舱embarkedboatbody: 尸体home.dest******目的：使用除survived字段外的数据进行k-means分组（分成两组:生/死），然后和survived字段对比，看看分组效果。''' # 加载数据df = pd.read_excel('titanic.xls')#print(df.shape) (1309, 14)#print(df.head())#print(df.tail())\"\"\" pclass survived name sex \\0 1 1 Allen, Miss. Elisabeth Walton female1 1 1 Allison, Master. Hudson Trevor male2 1 0 Allison, Miss. Helen Loraine female3 1 0 Allison, Mr. Hudson Joshua Creighton male4 1 0 Allison, Mrs. Hudson J C (Bessie Waldo Daniels) female age sibsp parch ticket fare cabin embarked boat body \\0 29.0000 0 0 24160 211.3375 B5 S 2 NaN1 0.9167 1 2 113781 151.5500 C22 C26 S 11 NaN2 2.0000 1 2 113781 151.5500 C22 C26 S NaN NaN3 30.0000 1 2 113781 151.5500 C22 C26 S NaN 135.04 25.0000 1 2 113781 151.5500 C22 C26 S NaN NaN home.dest0 St Louis, MO1 Montreal, PQ / Chesterville, ON2 Montreal, PQ / Chesterville, ON3 Montreal, PQ / Chesterville, ON4 Montreal, PQ / Chesterville, ON\"\"\" # 去掉无用字段df.drop(['body','name','ticket'], 1, inplace=True) df.convert_objects(convert_numeric=True)df.fillna(0, inplace=True) # 把NaN替换为0 # 把字符串映射为数字，例如&#123;female:1, male:0&#125;df_map = &#123;&#125; # 保存映射关系cols = df.columns.valuesfor col in cols: if df[col].dtype != np.int64 and df[col].dtype != np.float64: temp = &#123;&#125; x = 0 for ele in set(df[col].values.tolist()): if ele not in temp: temp[ele] = x x += 1 df_map[df[col].name] = temp df[col] = list(map(lambda val:temp[val], df[col])) #for key, value in df_map.iteritems():# print(key,value)#print(df.head()) # 由于是非监督学习，不使用labelx = np.array(df.drop(['survived'],1 ).astype(float))x = preprocessing.scale(x) clf = KMeans(n_clusters=2)clf.fit(x)# 上面已把数据分成两组 # 下面计算分组准确率是多少y = np.array(df['survived']) correct = 0for i in range(len(x)): predict_data = np.array(x[i].astype(float)) predict_data = predict_data.reshape(-1, len(predict_data)) predict = clf.predict(predict_data) #print(predict[0], y[i]) if predict[0] == y[i]: correct+=1 print(correct*1.0/len(x)) 执行结果： 1234567$ python sk_kmeans.py 0.692131398014 # 泰坦尼克号的幸存者和遇难者并不是随机分布的，在很大程度上取决于年龄、性别和社会地位$ python sk_kmeans.py 0.307868601986 # 结果出现很大波动，原因是它随机分配组(生:0,死:1）(生:1,死:0） # 1-0.307868601986是实际值$ python sk_kmeans.py 0.692131398014 K-means、和KNN算法比较 KNN(K-Nearest Neighbor)介绍 算法思路：如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。 看下面这幅图： KNN的算法过程是是这样的： 从上图中我们可以看到，图中的数据集是良好的数据，即都打好了label，一类是蓝色的正方形，一类是红色的三角形，那个绿色的圆形是我们待分类的数据。 如果K=3，那么离绿色点最近的有2个红色三角形和1个蓝色的正方形，这3个点投票，于是绿色的这个待分类点属于红色的三角形 如果K=5，那么离绿色点最近的有2个红色三角形和3个蓝色的正方形，这5个点投票，于是绿色的这个待分类点属于蓝色的正方形 我们可以看到，KNN本质是基于一种数据统计的方法！其实很多机器学习算法也是基于数据统计的。 KNN是一种memory-based learning，也叫instance-based learning，属于lazy learning。即它没有明显的前期训练过程，而是程序开始运行时，把数据集加载到内存后，不需要进行训练，就可以开始分类了。 具体是每次来一个未知的样本点，就在附近找K个最近的点进行投票。 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# k-近邻算法根据特征比较，然后提取样本集中特征最相似数据(最邻近)的分类标签# 假设样本有两个特征，那么大致从样本集分布的散点图判断，也就是二维空间来体现它们的位置关系# 这时采用点与点的距离可以计算出特定点与其他点的距离远近并加以排序，我们就可以知道谁离它最近了# 在从前k名最近的点中判断属于特征1和特征2的点的比例，比例大的特征为该特定点的特征# 所以k-近邻算法的步骤如下：# 计算已知类别数据集中的点与当前点之间的距离；# 按照距离递增次序排序；# 选取与当前点距离最小的k个点；# 确定前k个点所在类别的出现频率；# 返回前k个点所出现频率最高的类别作为当前点的预测分类。\"\"\"函数说明：创建数据集Parameters: 无Returns: dataset - 数据集 labels - 分类标签\"\"\"import numpy as npimport operatordef createDataSet(): dataset=np.array([[1,101],[5,89],[108,5],[115,8]]) labels=['爱情片','爱情片','动作片','动作片'] return dataset,labels\"\"\"函数说明：KNN算法，分类器Parameters: inX - 用于分类的特定数据(测试集) dataSet - 用于训练的数据(训练集) labes - 分类标签 k - kNN算法参数,选择距离最小的k个点Returns: sortedClassCount[0][0] - 分类结果\"\"\"def classfy(inX,dataSet,labels,k): # 返回数据集的行数 dataSetSize=dataSet.shape[0] # 使用tile数组实现inX的多行复制，满足矩阵相减的条件 diffMat=np.tile(inX,(dataSetSize,1))-dataSet # 计算距离（矩阵各行取平方和，最后开方） # 使用sum函数中的axis参数可以决定按行（1）相加 distances=((diffMat**2).sum(axis=1))**0.5 # 返回索引排序 sortedDistIndies=distances.argsort() # 记录类别次数 classCount=&#123;&#125; # 取出前k个元素的类别 for i in range(k): # 根据索引获取类别值 voteIlabel = labels[sortedDistIndies[i]] # dict.get(key,default=None)，在classCount字典里查找类别，如果没有则返回1 classCount[voteIlabel]=classCount.get(voteIlabel,0)+1 # reverse降序排序字典 sortedClassCount = sorted(classCount.items(),key=operator.itemgetter(1),reverse=True) return sortedClassCount[0][0]if __name__=='__main__': # 创建数据集 dataset,labels=createDataSet() # 打印数据集 # print(dataset) # print(labels) # 测试集 test=[101,20] test_class=classfy(test,dataset,labels,3) #打印分类结果 print(test_class) 总结： KNN和K-Means的区别 KNN计算方法为： 1计算测试数据与各个训练数据之间的距离； 2按照距离的递增关系进行排序； 3选取距离最小的K个点； 4确定前K个点所在类别的出现频率； 5返回前K个点中出现频率最高的类别作为测试数据的预测分类。 K-means的计算方法为： 1 随机选取k个中心点； 2 遍历所有数据，将每个数据划分到最近的中心点中； 3 计算每个聚类的平均值，并作为新的中心点 ； 4 重复2-3，直到这k个中线点不再变化（收敛了），或执行了足够多的迭代。","tags":[{"name":"KNN","slug":"KNN","permalink":"https://8bun.github.io/tags/KNN/"},{"name":"K-means","slug":"K-means","permalink":"https://8bun.github.io/tags/K-means/"},{"name":"聚类","slug":"聚类","permalink":"https://8bun.github.io/tags/聚类/"},{"name":"分类","slug":"分类","permalink":"https://8bun.github.io/tags/分类/"}],"categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://8bun.github.io/categories/机器学习/"}]},{"title":"都挺好","date":"2019-04-21T13:32:56.000Z","path":"2019/04/21/都挺好/","text":"​ 周末两天看完《都挺好》电视剧，这剧还真有点意思。46集不长不短，却叙述了一段一波三折的家庭故事。剧以大城市现实生活为开头，却在开头之后不久倒叙了主人公”苏明玉”小时候的家庭情况，小时候，家境拮据，母亲为了供大儿子”苏明哲”上美国名校，不顾一切卖掉了正面临高考的小女儿”苏明玉”正在居住的房间，可怜的小女儿只能赌气跟母亲住在一起，因为打小，母亲就”看不起”她，她要买本习题集都不给她，她母亲连女儿想考清华的梦想给破灭了，把她送去了一家师范学校，虽说可怜天下父母心，但这种家庭情况当母亲的观念也是”重男轻女”的较高境界，连父亲”苏大强”也是个奇葩，在妻子面前窝窝索索，简直就像个缩头乌龟，母亲家庭暴力的时候，当父亲从来都没有站出来说几句公道话，总是找着各种理由推卸责任。然而，当女儿的”苏明玉”与母亲对峙的这几年，她成长起来了。她学会独立，努力打工，终有一天发辅导班传单的时候，遇上了人生的恩师”蒙总”，遇上伯乐的千里马像脱了缰，不断狂奔，事业节节高升。 ​ 而另外一边，二哥因为冲动差点坐牢，盲目投资被骗，丢掉工作，离婚种种事情，一路的错误让他开始明白自己的过失，最终跑去非洲想干一番事业，他说过，有些事，有些艰苦，还是得吃的，开始明白小时候”啃老”的不对，家中对妹妹的”罪行”的严重。而大儿子大学考进美国名校，在家中怎么来说也是一件光宗耀祖的事情，可结婚定居美国之后，因为死爱面子，曾经自己失了业还“打肿脸充胖子”跟家里人说自己混的很好。然而身边的贤妻不断地在他“犯傻”的时候拯救了他，身为家中老大，但因为母亲过世的时候没在场而深深自责，想以实际行动弥补父亲，经常很多事情纵容了父亲的”无理”行为，还意识不到自己已经”分辨不出是非”了，在父亲面前依依顺顺，很多事情也是通过身边贤妻和妹妹的协助下才得以正确的解决。然而，身为老大，在母亲不在的时候，曾经多少次挽救了面临奔散的家庭。《都挺好》表面上是在讲重男轻女的因因果果，实则是在讲二代人的矛盾，是传统的家庭观念和快节奏的现代生活的矛盾，是啃老和养老的矛盾，是爱与不爱的矛盾。 ​ 最后，以编剧王三毛的一句总结这部剧吧，“原生家庭欠你的，你得靠自己找回来。找不回来就是一场灾难，找回来就「都挺好」”。希望所有曾受到家庭伤害的人，都能与苦难和解，活出明亮的人生。","tags":[{"name":"家庭","slug":"家庭","permalink":"https://8bun.github.io/tags/家庭/"},{"name":"都挺好","slug":"都挺好","permalink":"https://8bun.github.io/tags/都挺好/"}],"categories":[{"name":"都挺好","slug":"都挺好","permalink":"https://8bun.github.io/categories/都挺好/"}]},{"title":"网络包传输过程","date":"2019-03-24T10:22:00.000Z","path":"2019/03/24/网络包的传输过程/","text":"协议栈与套接字协议栈是一种网络控制软件，它主要根据套接字中记录的通信信息来工作。 在Window上使用netstat命令可以查看套接字的信息，使用-ano可以命令选择项，a表示显示所有套接字（包括正在通信和尚未开始通信等状态下的），n表示显示IP地址和端口号，o表示使用该套接字的程序PID。 在应用程序与服务器之间进行连接通信的过程，实质上进行了套接字的创建连接，通过套接字携带的目的端口、IP地址等进行匹配连接。创建套接字的过程非常简单，只要调用Socket库中的socket程序组件就可以了，实际上，创建完套接字后，该套接字传递到协议栈中后，协议栈会返回一个描述符，应用程序会将描述符存在内存中，以后委托协议栈使用哪个套接字来连接或收发数据，就可以直接出示描述符来避免多个套接字冲突。 那么连接过程究竟是如何的呢？ 数据连接过程协议栈中存在重要的TCP和IP模块，当套接字创建成功之后，客户端的协议栈生成一个SYN为1的TCP包，并发送给服务器，这个TCP包的头部还包含了客户端向服务器发送数据时使用的初始序号，以及服务器向客户端发送数据时需要用到的窗口大小。 协议栈将收到应用程序发过来的数据包加工后（加上协议头部），并不会马上发送出去，而是会根据一个叫MTU（Maximum Transmission Unit，最大传输单元）的参数进行判断，MTU的大小是协议栈协议头部和数据长度的总和，所以MTU-协议栈协议头部=`MSS（Maximum Segment Size，最大分段大小），当协议栈收到的数据接近或超过MSS时，就应该发送出去了。如果应用程序发送包的频率过小，很可能导致协议栈一直处于等待状态，为了解决这一问题，协议栈内部会有一个计时器规定等待发送的时间。 ​ IP模块会根据TCP传递的目的服务器IP地址、发送IP写入IP头部，而不会管IP是否正确。 ​ 实际上，一般计算机的网卡IP才是计算机的IP，每一个IP都可以将数据包传递到相应子网的以太网中，通过route print可以查看本地路由表判断该由哪块网卡发送。 ​ 生成IP头部之后，接下来IP模块还要将MAC头部追加到IP头部之前，MAC头部是MAC头部是以太网使用的头部，MAC地址是路由器的以太网（cwq简单看成局域网）地址，如00-80-C8-2D-82-EA（也可以使用’.’代替’-‘）MAC头部包含了14个字节（接收方的MAC地址，发送方的MAC地址，以太类型，48+48+16bit），你可以通过ARP（Address Resolution Protocol，地址解析协议）查询目标服务器（网卡）的MAC地址，如果对方与自己在同一个子网中，就可以通过广播响应得到，为了减少空间消耗，每查询过的MAC地址生成的ARP包，都会被缓存起来，你可以通过arp -a查询缓存条目。 ​ 接下来轮到网卡了，不过应该由网卡驱动程序来控制网卡（网卡的ROM中存在着世界上唯一的MAC地址，这是在生产的时候厂商就已经写入的），将IP数字信号转换为电信号（或光信号）发送出去，网卡中包含有MAC模块，网卡将发送包复制到缓冲区后，MAC模块会在缓冲区内将包取出，并在开头加上报头和起始帧分界符，在末尾加上用于检测错误的FCS（帧校验序列） ​ 报头是一串像10101010...这样1和0交替出现的比特序列，长度为56比特，它的作用是确定包的读取时机，主要是将1和0看成纵坐标画出的上下波动图代表电信号的高低电平的波动，如果有连续的1出现，那么此处就是读取时刻了。在这里有一个转换细节，就是连续的1出现和0出现，在电平波动上结果是一样的，那么就无法判断出这个读取时刻了，为了解决这一问题，引入了一个时钟信号，它是一段规律的电平波动，如在间隔时间，如 ，然后通过和数据信号进行一一对应（作用完将信号传递给接收方，接收方根据信号提取出时钟信号，然后计算出数据信号），就可实现连续的1和0的判断，末尾的FCS校验序列是用来检查在包传输过程中因噪声导致的波形紊乱、数据错误，由32bit组成，通过一组公式从包头到尾部计算出来的，接收方可以通过相同的公式计算出此序列，比较开始的FCS序列是否出现不同来判断包数据是否出现错误，差异化会导致包被丢弃 ​ 接下来就是交由网线发送了，发送信号的操作分为联众，一种使用集线器的半双工模式，一种使用交换机的全双工模式。半双工模式会先检查网线中是否存在其他正在传输的信号，有则待其传输完毕。 ​ 然后，PHY（MAU）模块会将信号转换为可在网线上传输的信号格式，并通过网线发送出去。 ​ 当这个包到达服务器后，服务器会发出一个包含ACK号（表示确认已收到包）、初始序号和窗口大小的SYN为1的包。 ​ 当这个包到达客户端后，客户端会返回一个包含确认收到包的ACK号的TCP包。 ​ 其中，为了防止网络攻击，通常会以一个随机数计算出的一个初始序号来代表第一个包的编号，并且通信双方在数据传递之前就已经知道这个初始序号。而ACK号是通过初始序号来计算得出的（表示为已经收到的第ACK字节之前的所有字节）。在得到对方确认之前，发送过的包都会保存在发送缓冲区中，以便TCP重传。 ​ 由于服务器的距离不是固定的，所以在返回ACK号所需时间也是不固定的。为了提高效率，TCP采用了动态调整等待时间（ACK号返回所需的时间）的方法。而为了能实现更高效地利用等待时间，客户端会在发送一个包之后，不等待ACK号的返回，而是直接发送后续的一系列包，我们称之为滑动窗口方式。 ​ 在服务器应用程序接收数据之前，会把接收到的包暂时先存储在自己的缓存区中，为了不过载，服务器会在返回ACK的时候顺带把自己缓冲区还能接收的数据空间大小返回。","tags":[{"name":"协议栈","slug":"协议栈","permalink":"https://8bun.github.io/tags/协议栈/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://8bun.github.io/tags/TCP-IP/"},{"name":"套接字","slug":"套接字","permalink":"https://8bun.github.io/tags/套接字/"},{"name":"网卡","slug":"网卡","permalink":"https://8bun.github.io/tags/网卡/"}],"categories":[{"name":"网络","slug":"网络","permalink":"https://8bun.github.io/categories/网络/"}]},{"title":"JavaScript DOM操作","date":"2019-03-21T13:40:15.000Z","path":"2019/03/21/JavaScript DOM操作/","text":"解释：DOM，指的是文档对象模型（Document Object Model）。是针对HTML和XML文档的 一个API,描绘了一个层次化的节点树，允许开发人员添加、删除和修改页面的某一部分。 HTML DOM树形结构如下： 事件三要素：事件源（受监听的html标签）、事件（监听器）、事件驱动程序（动作）。 获取时间源的方式（DOM节点的获取） 获取事件源的常见方式如下： 12345var div1 = document.getElementById(\"box1\"); //方式一：通过id获取单个标签var arr1 = document.getElementsByTagName(\"div\"); //方式二：通过 标签名 获得 标签数组，所以有svar arr2 = document.getElementsByClassName(\"hehe\"); //方式三：通过 类名 获得 标签数组，所以有s 绑定事件的方式 方式一：直接绑定匿名函数 123456789&lt;div id=\"box1\" &gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var div1 = document.getElementById(\"box1\"); //绑定事件的第一种方式 div1.onclick = function () &#123; alert(\"我是弹出的内容\"); &#125;&lt;/script&gt; 方式二：先单独定义函数，再绑定 1234567891011 &lt;div id=\"box1\" &gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; var div1 = document.getElementById(\"box1\"); //绑定事件的第二种方式 div1.onclick = fn; //注意，这里是fn，不是fn()。fn()指的是返回值。 //单独定义函数 function fn() &#123; alert(\"我是弹出的内容\"); &#125;&lt;/script&gt; 方式三：行内绑定 12345678910&lt;!--行内绑定--&gt;&lt;div id=\"box1\" onclick=\"fn()\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; function fn() &#123; alert(\"我是弹出的内容\"); &#125;&lt;/script&gt; 事件驱动程序 我们在上面是拿alert举例，不仅如此，我们还可以操作标签的属性和样式。举例如下： 点击鼠标时，原本粉色的div变大了，背景变红： 123456789101112131415161718192021&lt;head&gt;&lt;style&gt; #box1&#123; width:100px; height:100px; background-color:pink; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"box1\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; var div1=document.getElementById(\"box1\"); //点击鼠标时，原本粉色的div变大了，背景变红了 div1.onclick = function()&#123; div1.style.width = \"200px\"; //属性值要写引号 div1.style.height = \"200px\"; div1.style.backgroundColor = \"red\"; //属性名是backgroundColor，不是background-color &#125; &lt;/script&gt;&lt;/body&gt; 实现效果如下： onload事件 onload事件比较特殊，这里单独讲一下。 当页面加载（文本和图片）完毕的时候，触发onload事件。 举例： 12345&lt;script type=\"text/javascript\"&gt; window.onload = function () &#123; console.log(\"smyhvae\"); //等页面加载完毕时，打印字符串 &#125;&lt;/script&gt; 有一点我们要知道：js的加载是和html同步加载的。因此，如果使用元素在定义元素之前，容易报错。这个时候，onload事件就能派上用场了，我们可以把使用元素的代码放在onload里，就能保证这段代码是最后执行。 建议是：整个页面上所有元素加载完毕在执行js内容。所以，window.onload可以预防使用标签在定义标签之前。 事件举例：京东顶部广告栏 比如上面这张图，当鼠标点击右上角的X时，关掉整个广告栏，这就要用到事件。 代码实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang=\"en\"&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .top-banner &#123; background-color: pink; height: 80px; &#125; .w &#123; width: 1210px; margin: 10px auto; position: relative; &#125; img &#123; display: block; width: 1210px; height: 80px; background-color: blue; &#125; a &#123; position: absolute; top: 5px; right: 5px; color: #fff; background-color: #000; text-decoration: none; width: 20px; height: 20px; font: 700 14px/20px \"simsum\"; text-align: center; &#125; .hide &#123; display: none!important; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"top-banner\" id=\"topBanner\"&gt; &lt;div class=\"w\"&gt; &lt;img src=\"\" alt=\"\"/&gt; &lt;a href=\"#\" id=\"closeBanner\"&gt;×&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;script&gt; //需求：点击案例，隐藏盒子。 //思路：点击a链接，让top-banner这个盒子隐藏起来（加隐藏类名）。 //1.获取事件源和相关元素 var closeBanner = document.getElementById(\"closeBanner\"); var topBanner = document.getElementById(\"topBanner\"); //2.绑定事件 closeBanner.onclick = function () &#123; //3.书写事件驱动程序 //类控制// topBanner.className += \" hide\"; //保留原类名，添加新类名 topBanner.className = \"hide\";//替换旧类名（方式一），改变所属类，应用hide类的样式// topBanner.style.display = \"none\"; //方式二：与上一行代码的效果相同 &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意最后一行代码，这种方式会替换旧类名，意思是，不管之前的类名叫什么，都会被修改。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://8bun.github.io/tags/JavaScript/"},{"name":"DOM","slug":"DOM","permalink":"https://8bun.github.io/tags/DOM/"},{"name":"事件","slug":"事件","permalink":"https://8bun.github.io/tags/事件/"}],"categories":[{"name":"前端","slug":"前端","permalink":"https://8bun.github.io/categories/前端/"}]}]}